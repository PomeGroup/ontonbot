x-common-extra-hosts: &default-extra-hosts
  extra_hosts:
    - "${MINI_APP_DOMAIN}:${IP_RANGE_BASE}"
    - "host.docker.internal:host-gateway"

x-common-env: &common-env
  ACME_AGREE: true
  BOT_TOKEN: ${BOT_TOKEN}
  CLIENT_WEB_DOMAIN: ${CLIENT_WEB_DOMAIN}
  DATABASE_URL: ${DATABASE_URL}
  DATABASE_URL_NFT_MANAGER: ${DATABASE_URL_NFT_MANAGER}
  ENV: ${ENV}
  PGDATA: "/var/lib/postgresql/data/pgdata"
  GOLANG_SERVER_PORT: ${GOLANG_SERVER_PORT}
  IP_CLAMAV: ${IP_CLAMAV}
  IP_CLIENT_WEB: ${IP_CLIENT_WEB}
  IP_METABASE: ${IP_METABASE}
  IP_MINI_APP: ${IP_MINI_APP}
  IP_MINIO: ${IP_MINIO}
  IP_PARTICIPANT_TMA: ${IP_PARTICIPANT_TMA}
  IP_PGADMIN: ${IP_PGADMIN}
  IP_RANGE_BASE: ${IP_RANGE_BASE}
  IP_SWAGGER_UI: ${IP_SWAGGER_UI}
  IP_TELEGRAM_BOT: ${IP_TELEGRAM_BOT}
  IP_WEBSITE: ${IP_WEBSITE}
  IP_NFT_MANAGER: ${IP_NFT_MANAGER}
  IP_RABBITMQ: ${IP_RABBITMQ}
  IP_REDIS: ${IP_REDIS}
  LOCAL_DOMAIN: ${LOCAL_DOMAIN}
  METABASE_DOMAIN: ${METABASE_DOMAIN}
  MINI_APP_DOMAIN: ${MINI_APP_DOMAIN}
  MINI_APP_PORT: ${MINI_APP_PORT}
  MINIO_DASHBOARD_PORT: ${MINIO_DASHBOARD_PORT}
  MINIO_ENDPOINT: ${MINIO_ENDPOINT}
  MINIO_PORT: ${MINIO_PORT}
  MINIO_PUBLIC_URL: ${MINIO_PUBLIC_URL}
  MINIO_ROOT_PASSWORD: ${MINIO_ROOT_PASSWORD}
  MINIO_ROOT_USER: ${MINIO_ROOT_USER}
  MINIO_STORAGE_ADMIN_DOMAIN: ${MINIO_STORAGE_ADMIN_DOMAIN}
  MINIO_STORAGE_DOMAIN: ${MINIO_STORAGE_DOMAIN}
  MONITORING_DOMAIN: ${MONITORING_DOMAIN}
  NEXT_PUBLIC_API_BASE_URL: ${NEXT_PUBLIC_API_BASE_URL}
  NEXT_PUBLIC_APP_BASE_URL: ${NEXT_PUBLIC_APP_BASE_URL}
  NEXT_PUBLIC_GTM: ${NEXT_PUBLIC_GTM}
  NEXT_PUBLIC_BOT_USERNAME: ${NEXT_PUBLIC_BOT_USERNAME}
  NODE_ENV: ${NODE_ENV}
  NODE_TLS_REJECT_UNAUTHORIZED: ${NODE_TLS_REJECT_UNAUTHORIZED}
  ONTON_API_KEY: ${ONTON_API_KEY}
  ONTON_DOMAIN: ${ONTON_DOMAIN}
  PARTICIPANT_TMA_PORT: ${PARTICIPANT_TMA_PORT}
  PGADMIN_DOMAIN: ${PGADMIN_DOMAIN}
  PORT_CLIENT_WEB: ${PORT_CLIENT_WEB}
  CLAMAV_PORT: ${CLAMAV_PORT}
  PORT_METABASE: ${PORT_METABASE}
  PORT_PGADMIN: ${PORT_PGADMIN}
  PORT_WEB_SITE: ${PORT_WEB_SITE}
  POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
  POSTGRES_PORT: ${POSTGRES_PORT}
  POSTGRES_USER: ${POSTGRES_USER}
  NFT_MANAGER_PORT: ${NFT_MANAGER_PORT}
  RABBITMQ_DEFAULT_USER: ${RABBITMQ_DEFAULT_USER}
  RABBITMQ_DEFAULT_PASS: ${RABBITMQ_DEFAULT_PASS}
  RABBITMQ_DOMAIN: ${RABBITMQ_DOMAIN}
  RABBITMQ_MANAGEMENT_PORT: ${RABBITMQ_MANAGEMENT_PORT}
  RABBITMQ_NODE_PORT: ${RABBITMQ_NODE_PORT}
  REDIS_DATABASES: ${REDIS_DATABASES}
  REDIS_HOST: ${IP_REDIS}
  REDIS_PASSWORD: ${REDIS_PASSWORD}
  REDIS_PORT: ${REDIS_PORT}
  TELEGRAM_BOT_PORT: ${TELEGRAM_BOT_PORT}
  TG_NOTIFICATION_CHANELL: ${TG_NOTIFICATION_CHANELL}
  TON_CENTER_ENDPOINT: ${TON_CENTER_ENDPOINT}
  USE_MAIN_IP_TO_EXPOSE: ${USE_MAIN_IP_TO_EXPOSE}
  MINI_APP_SOCKET_DOMAIN: ${MINI_APP_SOCKET_DOMAIN}
  NEXT_PUBLIC_SOCKET_URL: ${NEXT_PUBLIC_SOCKET_URL}
  IP_SOCKET: ${IP_SOCKET}
  SOCKET_PORT: ${SOCKET_PORT}
  ONTON_API_SECRET: ${ONTON_API_SECRET}
  NEXT_PUBLIC_ENV: ${NEXT_PUBLIC_ENV}
  IP_MINI_APP_MODERATION: ${IP_MINI_APP_MODERATION}
  SWAGGER_UI_DOMAIN: ${SWAGGER_UI_DOMAIN}
  SWAGGER_UI_PORT: ${SWAGGER_UI_PORT}

services:
  caddy:
    image: caddy:latest
    container_name: ${ENV}-caddy
    restart: unless-stopped
    profiles:
      - front-end-development
      - minimal
      - expecting-mini-app
      - full
    ports:
#      - "80:80"
      - "443:443"
    volumes:
      - ./data/caddy_data:/data
      - ./data/caddy_config:/config
      - ./devops/generate-caddyfile.sh:/usr/bin/envsh/generate-caddyfile.sh:delegate
      - ./devops/cert:/certs
    networks:
      onton-network:
        ipv4_address: "${IP_CADDY}"
    environment:
      <<: *common-env
    <<: *default-extra-hosts
#    network_mode: "host"
    entrypoint: /usr/bin/envsh/generate-caddyfile.sh

  minio:
    hostname: minio
    container_name: ${ENV}-minio
    image: minio/minio
    restart: unless-stopped
    profiles:
      - front-end-development
      - expecting-mini-app
      - minimal
      - full
    networks:
      onton-network:
        ipv4_address: "${IP_MINIO}"
    ports:
      - "${MINIO_PORT}:${MINIO_PORT}"
      - "${MINIO_DASHBOARD_PORT}:${MINIO_DASHBOARD_PORT}"
    volumes:
      - ./data/minio_data:/data
      - ./devops/minio-init.sh:/usr/bin/entrypoint.sh:delegate
    entrypoint: [ "/usr/bin/entrypoint.sh" ] # Use the custom entrypoint script
    environment:
      <<: *common-env

  postgres:
    hostname: postgres
    container_name: ${ENV}-postgres
    image: postgres:16.3-alpine3.20
    restart: unless-stopped
    ports:
      - "${POSTGRES_PORT}:5432"
    profiles:
      - front-end-development
      - expecting-mini-app
      - full
      - minimal
    environment:
      <<: *common-env
    volumes:
      - ./data/db_data:/var/lib/postgresql/data
    networks:
      onton-network:
        ipv4_address: "${IP_POSTGRES}"

  redis:
    image: redis:7.4.1-bookworm
    hostname: redis
    container_name: ${ENV}-redis
    restart: unless-stopped
    volumes:
      - ./data/redis_data:/data
    ports:
      - "${REDIS_PORT}:${REDIS_PORT}"
    profiles:
      - front-end-development
      - expecting-mini-app
      - minimal
      - full
    command: redis-server --save "" --appendonly no
    environment:
      <<: *common-env
    networks:
      onton-network:
        ipv4_address: ${IP_REDIS}

  clamav:
    image: mkodockx/docker-clamav
    hostname: clamav
    container_name: ${ENV}-clamav
    ports:
      - "${CLAMAV_PORT}:3310"
    profiles:
      - front-end-development
      - manual-apps
      - full
    environment:
      - CLAMD_SETTINGS_MAXQUEUE=200
      - CLAMD_SETTINGS_LOGTIME=1
    volumes:
      - clamav_data:/var/lib/clamav # Persist virus definition database
    restart: unless-stopped
    networks:
      onton-network:
        ipv4_address: "${IP_CLAMAV}"

  pgadmin:
    image: dpage/pgadmin4
    container_name: ${ENV}-pgadmin
    restart: always
    environment:
      PGADMIN_DEFAULT_EMAIL: ${PGADMIN_DEFAULT_EMAIL}
      PGADMIN_DEFAULT_PASSWORD: ${PGADMIN_DEFAULT_PASSWORD}
    profiles:
      - full
      - manual-apps
      - minimal
    ports:
      - "${PORT_PGADMIN}:80"
    depends_on:
      - postgres
    networks:
      onton-network:
        ipv4_address: ${IP_PGADMIN}
    volumes:
      - pgadmin:/var/lib/pgadmin

  telegram-bot:
    container_name: ${ENV}-telegram-bot
    build:
      context: ./telegram-bot
      target: production
    restart: "unless-stopped"
    ports:
      - "${TELEGRAM_BOT_PORT}:${TELEGRAM_BOT_PORT}"
    profiles:
      - front-end-development
      - manual-apps
      - full
    environment:
      <<: *common-env
    depends_on:
      - postgres
    networks:
      onton-network:
        ipv4_address: "${IP_TELEGRAM_BOT}"

  mini-app:
    hostname: mini-app
    container_name: ${ENV}-mini-app
    ports:
      - "${MINI_APP_PORT}:${MINI_APP_PORT}"
    profiles:
      - full
    build:
      context: ./mini-app
      target: production
      args:
        <<: *common-env
    restart: "unless-stopped"
    stop_grace_period: 10s
    stop_signal: SIGTERM
    environment:
      <<: *common-env
    depends_on:
      - postgres
      - redis
    volumes:
      - ./data/drizzle_data:/app/drizzle
    networks:
      onton-network:
        ipv4_address: ${IP_MINI_APP}

  mini-app-sbt-worker:
    hostname: mini-app-sbt-worker
    container_name: ${ENV}-mini-app-sbt-worker
    build:
      context: ./mini-app
      target: production
      args:
        <<: *common-env
    restart: "unless-stopped"
    stop_grace_period: 10s
    stop_signal: SIGTERM
    profiles:
      - full
    environment:
      <<: *common-env
    depends_on:
      - postgres
      - redis
    volumes:
      - ./data/drizzle_data:/app/drizzle
    networks:
      onton-network:
        ipv4_address: "${IP_MINI_APP_CRON}"
    command: [ "yarn", "run", "start-cron" ]

  mini-app-reward-worker:
    hostname: mini-app-reward-worker
    container_name: ${ENV}-mini-app-reward-worker
    build:
      context: ./mini-app
      target: production
      args:
        <<: *common-env
    restart: "unless-stopped"
    stop_grace_period: 10s
    stop_signal: SIGTERM
    profiles:
      - full
    environment:
      <<: *common-env
    depends_on:
      - postgres
      - redis
    volumes:
      - ./data/drizzle_data:/app/drizzle
    networks:
      onton-network:
        ipv4_address: "${IP_MINI_APP_CRON}"
    command: [ "yarn", "run", "start-cron-reward" ]

  mini-app-ordinary-worker:
    hostname: mini-app-ordinary-worker
    container_name: ${ENV}-mini-app-ordinary-worker
    build:
      context: ./mini-app
      target: production
      args:
        <<: *common-env
    restart: "unless-stopped"
    stop_grace_period: 10s
    stop_signal: SIGTERM
    profiles:
      - full
    environment:
      <<: *common-env
    depends_on:
      - postgres
      - redis
    volumes:
      - ./data/drizzle_data:/app/drizzle
    networks:
      onton-network:
        ipv4_address: "${IP_MINI_APP_CRON}"
    command: [ "yarn", "run", "start-cron-ordinary" ]

  mini-app-moderation-bot:
    hostname: mini-app-moderation-bot
    container_name: ${ENV}-mini-app-moderation-bot
    build:
      context: ./mini-app
      target: production
      args:
        <<: *common-env
    restart: "unless-stopped"
    stop_grace_period: 10s
    stop_signal: SIGTERM
    profiles:
      - full
    environment:
      <<: *common-env
    depends_on:
      - postgres
      - redis
    volumes:
      - ./data/drizzle_data:/app/drizzle
    networks:
      onton-network:
        ipv4_address: "${IP_MINI_APP_MODERATION}"
    command: [ "yarn", "run", "start:moderation" ]
  mini-app-poa-worker:
    hostname: mini-app-poa-worker
    container_name: ${ENV}-mini-app-poa-worker
    build:
      context: ./mini-app
      target: production
      args:
        <<: *common-env
    restart: "unless-stopped"
    stop_grace_period: 10s
    stop_signal: SIGTERM
    profiles:
      - full
    environment:
      <<: *common-env
    depends_on:
      - postgres
      - redis
      - rabbitmq
    volumes:
      - ./data/drizzle_data:/app/drizzle
    networks:
      onton-network:
        ipv4_address: "${IP_POA_WORKER}"
    command: [ "yarn", "run", "start:poa" ]

  mini-app-notification-socket:
    hostname: mini-app-notification-socket
    container_name: ${ENV}-mini-app-notification-socket
    ports:
      - "${SOCKET_PORT}:${SOCKET_PORT}"
    build:
      context: ./mini-app
      target: production
      args:
        <<: *common-env
    restart: "unless-stopped"
    stop_grace_period: 10s
    stop_signal: SIGTERM
    profiles:
      - full
    environment:
      <<: *common-env
    depends_on:
      - postgres
      - redis
      - rabbitmq
    volumes:
      - ./data/drizzle_data:/app/drizzle
    networks:
      onton-network:
        ipv4_address: "${IP_SOCKET}"
    command: [ "yarn", "run", "start:socket" ]

  participant-tma:
    hostname: participant-tma
    container_name: ${ENV}-participant-tma
    <<: *default-extra-hosts
    ports:
      - "${PARTICIPANT_TMA_PORT}:${PARTICIPANT_TMA_PORT}"
    profiles:
      - full
    build:
      context: ./newton/
      dockerfile: ./apps/participant-tma/Dockerfile
      args:
        <<: *common-env
    restart: "unless-stopped"
    environment:
      <<: *common-env
    networks:
      onton-network:
        ipv4_address: "${IP_PARTICIPANT_TMA}"

  website:
    hostname: website
    container_name: ${ENV}-website
    build:
      context: ./website
      args:
        <<: *common-env
    restart: "unless-stopped"
    profiles:
      - full
    ports:
      - "${PORT_WEB_SITE}:${PORT_WEB_SITE}"
    environment:
      <<: *common-env
    networks:
      onton-network:
        ipv4_address: ${IP_WEBSITE}

  metabase:
    image: metabase/metabase:v0.50.18.3
    hostname: metabase
    container_name: ${ENV}-metabase
    restart: unless-stopped
    ports:
      - "${PORT_METABASE}:3000"
    profiles:
      - full
    volumes:
      - /dev/urandom:/dev/random:ro
    environment:
      MB_DB_TYPE: postgres
      MB_DB_DBNAME: ${POSTGRES_METABASE_DB}
      MB_DB_PORT: ${POSTGRES_PORT}
      MB_DB_USER: ${POSTGRES_USER}
      MB_DB_PASS: ${POSTGRES_PASSWORD}
      MB_LOG_LEVEL: error
      MB_ENCRYPTION_SECRET_KEY: ${MB_ENCRYPTION_SECRET_KEY}
      MB_REDIRECT_ALL_REQUESTS_TO_HTTPS: ${MB_REDIRECT_ALL_REQUESTS_TO_HTTPS}
    networks:
      onton-network:
        ipv4_address: ${IP_METABASE}
    depends_on:
      - postgres
    healthcheck:
      test: curl --fail -I http://localhost:3000/api/health || exit 1
      interval: 15s
      timeout: 5s
      retries: 5

  client-web:
    hostname: client-web
    container_name: ${ENV}-client-web
    <<: *default-extra-hosts
    ports:
      - "${PORT_CLIENT_WEB}:${PORT_CLIENT_WEB}"
    profiles:
      - full
    build:
      context: ./client-web-panel
      dockerfile: Dockerfile
      target: production
      args:
        ENV_TYPE: production
        NEXT_PUBLIC_BACKEND_URL_CLIENT: ${NEXT_PUBLIC_BACKEND_URL_CLIENT}
        CLIENT_API_JWT_SECRET: ${CLIENT_API_JWT_SECRET}
        CLIENT_API_FIXED_KEY: ${CLIENT_API_FIXED_KEY}
        CLIENT_API_FIXED_USER: ${CLIENT_API_FIXED_USER}
        CLIENT_API_FIXED_ORGANIZER: ${CLIENT_API_FIXED_ORGANIZER}
        PORT_CLIENT_WEB: ${PORT_CLIENT_WEB}
    restart: "unless-stopped"
    environment:
      NEXT_PUBLIC_BACKEND_URL_CLIENT: ${NEXT_PUBLIC_BACKEND_URL_CLIENT}
      CLIENT_API_JWT_SECRET: ${CLIENT_API_JWT_SECRET}
      CLIENT_API_FIXED_KEY: ${CLIENT_API_FIXED_KEY}
      CLIENT_API_FIXED_USER: ${CLIENT_API_FIXED_USER}
      CLIENT_API_FIXED_ORGANIZER: ${CLIENT_API_FIXED_ORGANIZER}
      PORT_CLIENT_WEB: ${PORT_CLIENT_WEB}
    #    depends_on:
    #      - caddy
    networks:
      onton-network:
        ipv4_address: ${IP_CLIENT_WEB}
  rabbitmq:
    image: "rabbitmq:4.0.4-management-alpine"
    container_name: ${ENV}-rabbitmq
    hostname: rabbitmq
    profiles:
      - front-end-development
      - expecting-mini-app
      - full
      - minimal
    logging:
      driver: "json-file"
      options:
        max-size: "1G"
        max-file: "2"
    ports:
      - "${RABBITMQ_MANAGEMENT_PORT}:15672" # Management console
      - "${RABBITMQ_NODE_PORT}:${RABBITMQ_NODE_PORT}" # AMQP port
    environment:
      - RABBITMQ_DEFAULT_USER=${RABBITMQ_DEFAULT_USER}
      - RABBITMQ_DEFAULT_PASS=${RABBITMQ_DEFAULT_PASS}
      - RABBITMQ_NODE_PORT=${RABBITMQ_NODE_PORT}
    volumes:
      - rabbitmq_data:/var/lib/rabbitmq # Persist data
    restart: unless-stopped
    tty: true
    networks:
      onton-network:
        ipv4_address: ${IP_RABBITMQ}

  swagger-ui:
    image: swaggerapi/swagger-ui
    environment:
      SWAGGER_JSON: ""
      SWAGGER_UI_CSS: /usr/share/nginx/html/custom.css
    profiles:
      - swagger
      - full
      - minimal
    ports:
      - "${SWAGGER_UI_PORT}:8080"
    volumes:
      - ./swagger/ExternalSeller.yml:/usr/share/nginx/html/swagger/ExternalSeller.yaml
      - ./swagger/GameRewards.yml:/usr/share/nginx/html/swagger/GameRewards.yaml
      - ./swagger/NFTApi.yml:/usr/share/nginx/html/swagger/NFTApi.yaml
      - ./swagger/swagger-initializer.js:/usr/share/nginx/html/swagger-initializer.js
      - ./swagger/custom.css:/usr/share/nginx/html/swagger/custom.css
      - ./swagger/home.html:/usr/share/nginx/html/swagger/home.html
      - ./swagger/index.html:/usr/share/nginx/html/swagger/index.html
    depends_on:
      - caddy
    networks:
      onton-network:
        ipv4_address: "${IP_SWAGGER_UI}"

networks:
  onton-network:
    driver: bridge
    name: ${NETWORK_NAME}

    ipam:
      config:
        - subnet: "${IP_RANGE_START}.0.0/${IP_RANGE_SUBNET}"
volumes:
  pgadmin:
  clamav_data:
  rabbitmq_data:
