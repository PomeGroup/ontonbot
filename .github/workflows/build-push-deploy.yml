name: Build, Push, and Deploy Services

on:
  push:
    branches:
      - "dev"
      - "staging"
    paths:
      - 'client-web-panel/**'
      - 'devops/**'
      - 'docker-compose.yml'
      - 'giveaway-checker/**'
      - 'golang-server/**'
      - 'mini-app/**'
      - 'newton/**'
      - 'telegram-bot/**'
      - 'website/**'
      - '.github/workflows/**'
      - 'Trigger-full-build.txt'

jobs:
  determine-services:
    runs-on: self-hosted
    outputs:
      services_to_build: ${{ steps.determine-services.outputs.services }}
    steps:
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Determine Services to Build
        id: determine-services
        env:
          TELEGRAM_BOT_TOKEN_FOR_DEPLOYMENT: ${{ vars.TELEGRAM_BOT_TOKEN_FOR_DEPLOYMENT }}
          TELEGRAM_CHAT_ID_FOR_DEPLOYMENT: ${{ vars.TELEGRAM_CHAT_ID_FOR_DEPLOYMENT }}
        run: |
          echo "Determining services that have changed..."
          changed_files=$(git diff --name-only "${{ github.event.before }}" "${{ github.sha }}")
          echo "Changed files: $changed_files"
          declare -a services_to_build=()
          # Define service directory mappings
          declare -A service_dirs=(
            ["client-web"]="client-web-panel"
            ["giveaway-checker"]="giveaway-checker"
            ["golang-server"]="golang-server"
            ["mini-app"]="mini-app"
            ["nft-microservice"]="newton/apps/nft-manager"
            ["participant-tma"]="newton/apps/participant-tma"
            ["telegram-bot"]="telegram-bot"
            ["website"]="website"
            ["golang-worker"]="golang-server/worker"
            ["caddy"]="devops/caddy"
          )
          # If Trigger-full-build.txt has changed, add all services
          if echo "$changed_files" | grep -q "^Trigger-full-build.txt$"; then
            echo "Trigger-full-build.txt has changed, rebuilding all services."
            services_to_build=("${!service_dirs[@]}")
          else
            for service in "${!service_dirs[@]}"; do
              if echo "$changed_files" | grep -q "^${service_dirs[$service]}"; then
                services_to_build+=("$service")
              fi
            done
          fi
          # Add 'giveaway-checker' if no services have changed
          if [ ${#services_to_build[@]} -eq 0 ]; then
            echo "No services have changed, defaulting to 'giveaway-checker'."
          services_to_build+=("giveaway-checker")
          fi
          if [ ${#services_to_build[@]} -eq 0 ]; then
            echo "No services have changes, skipping build."
            services_json="[]"
          else
            services_json=$(printf '%s\n' "${services_to_build[@]}" | jq -R . | jq -s -c .)
          fi

          echo "Services to build: $services_json"
          echo "services=$services_json" >> $GITHUB_OUTPUT
          
          if [ -z "TELEGRAM_BOT_TOKEN_FOR_DEPLOYMENT" ] || [ -z "$TELEGRAM_CHAT_ID_FOR_DEPLOYMENT" ]; then
            echo "Error: Telegram  deployment bot vars  are not set or are empty."
            exit 1
          fi

          curl -s -X POST "https://api.telegram.org/bot$TELEGRAM_BOT_TOKEN_FOR_DEPLOYMENT/sendMessage" \
            -d chat_id="$TELEGRAM_CHAT_ID_FOR_DEPLOYMENT" \
            -d text="
            Hi there! 
            ðŸ”„ Build Started for ${{ github.repository }}
          
            ðŸ§‘ â€ðŸ’»Actor: ${{ github.actor }}
            ðŸ§ Changed services:  $services_json  
            ðŸ“ branch: ${{ github.ref }}
            ðŸ” See Changes: https://github.com/${{ github.repository }}/commit/${{ github.sha }}"
          

#  build-and-push:
#    runs-on: self-hosted
#    needs: determine-services
#    if: ${{ needs.determine-services.outputs.services_to_build != '[]' }}
#    strategy:
#      matrix:
#        service: ${{ fromJson(needs.determine-services.outputs.services_to_build) }}
#    permissions:
#      contents: read
#      packages: write
#      actions: write
#    env:
#      ALLMYSECRETS: ${{ toJSON(secrets) }}
#      ALLMYVARS: ${{ toJSON(vars) }}
#    steps:
#      - name: Send Telegram Message - Build Start
#        env:
#          TELEGRAM_BOT_TOKEN: ${{ vars.TELEGRAM_BOT_TOKEN_FOR_DEPLOYMENT }}
#          TELEGRAM_CHAT_ID: ${{ vars.TELEGRAM_CHAT_ID_FOR_DEPLOYMENT }}
#        run: |
#          if [ -z "$TELEGRAM_BOT_TOKEN" ] || [ -z "$TELEGRAM_CHAT_ID" ]; then
#            echo "Error: Telegram deployment bot vars are not set or are empty."
#            exit 1
#          fi
#
#          curl -s -X POST "https://api.telegram.org/bot$TELEGRAM_BOT_TOKEN/sendMessage" \
#            -d chat_id="$TELEGRAM_CHAT_ID" \
#            -d text="
#            Hi there!
#            ðŸ”„ Build Started for ${{ github.repository }}
#            ðŸ“ branch: ${{ github.ref }}
#
#            ðŸ§‘ â€ðŸ’»Actor: ${{ github.actor }}
#
#            ðŸ–Š   message: ${{ github.event.head_commit.message }}
#
#            ðŸ” See Changes: https://github.com/${{ github.repository }}/commit/${{ github.sha }}"
#
#      - name: Checkout Code
#        uses: actions/checkout@v4
#
#      - name: Set up Docker Buildx
#        uses: docker/setup-buildx-action@v3.7.1
#
#      - name: Authenticate to GitHub Container Registry
#        env:
#          CR_PAT: ${{ secrets.GITHUB_TOKEN }}
#        run: echo "${CR_PAT}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
#
#      - name: Build and push image for ${{ matrix.service }}
#
#        run: |
#          declare -A services=(
#            ["nft-microservice"]="newton/apps/nft-manager"
#            ["participant-tma"]="newton/apps/participant-tma"
#            ["client-web"]="client-web-panel"
#            ["mini-app-cron"]="mini-app"
#            ["giveaway-checker"]="giveaway-checker"
#            ["golang-server"]="golang-server"
#            ["golang-worker"]="golang-server/worker"
#            ["mini-app"]="mini-app"
#            ["telegram-bot"]="telegram-bot"
#            ["website"]="website"
#            ["caddy"]="devops/caddy"
#          )
#          branch_name="${{ github.ref_name }}"
#          service="${{ matrix.service }}"
#          build_path="${services[$service]}"
#          repository=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
#          service=$(echo "$service" | tr '[:upper:]' '[:lower:]')
#
#          image_name="ghcr.io/${repository}/${service}"
#          tag_commit="${image_name}:${branch_name}-${{ github.run_id }}"
#          tag_latest="${image_name}:${branch_name}-latest"
#
#          echo "Processing service: $service"
#          echo "Build path: $build_path"
#
#          if  [ "$service" == "participant-tma" ]; then
#            dockerfile_path="newton/apps/participant-tma/Dockerfile"
#            build_context="./newton"
#          elif [ "$service" == "nft-microservice" ]; then
#            dockerfile_path="newton/apps/nft-manager/Dockerfile"
#            build_context="./newton"
#          elif [ "$service" == "caddy" ]; then
#            dockerfile_path="devops/caddy/Dockerfile"
#            build_context="./devops/caddy/"
#          elif [ "$service" == "golang-server" ]; then
#            dockerfile_path="golang-server/server/Dockerfile"
#            build_context="./golang-server"
#          elif [ "$service" == "golang-worker" ]; then
#            dockerfile_path="golang-server/worker/Dockerfile"
#            build_context="./golang-server"
#          else
#            dockerfile_path="$build_path/Dockerfile"
#            build_context="$build_path"
#          fi
#
#          if [ -f "$dockerfile_path" ]; then
#            echo "Using Dockerfile at $dockerfile_path"
#            # Create commit details file
#            COMMIT_DETAILS_FILE=$(mktemp)
#            echo "Commit SHA: ${{ github.sha }}" > "$COMMIT_DETAILS_FILE"
#            echo "Commit Author: ${{ github.actor }}" >> "$COMMIT_DETAILS_FILE"
#            echo "Commit Message: ${{ github.event.head_commit.message }}" >> "$COMMIT_DETAILS_FILE"
#            echo "Commit Date: ${{ github.event.head_commit.timestamp }}" >> "$COMMIT_DETAILS_FILE"
#
#            # Move the commit details file to the appropriate build context
#            mv "$COMMIT_DETAILS_FILE" "$build_context/commit_details.txt"
#            # Create temporary build args file
#            BUILD_ARGS_FILE=$(mktemp)
#
#            # Extract environment variables for the current branch
#            branch_prefix="${branch_name^^}_"
#            echo "Extracting environment variables for the branch prefix: $branch_prefix"
#
#            # Function to safely process environment variables
#            process_env_vars() {
#              local json_str="$1"
#              local prefix="$2"
#              local outfile="$3"
#
#              # Ensure JSON is properly formatted
#              echo "$json_str" | jq -r --arg prefix "$prefix" \
#                'with_entries(select(.key | startswith($prefix))) |
#                to_entries[] |
#                "\(.key | sub($prefix; ""))=\(.value)"' >> "$outfile" || true
#            }
#
#            # Process secrets with error handling
#            if [ -n "$ALLMYSECRETS" ]; then
#              echo "Processing secrets..."
#              process_env_vars "$ALLMYSECRETS" "$branch_prefix" "$BUILD_ARGS_FILE"
#
#            fi
#
#            # Process vars with error handling
#            if [ -n "$ALLMYVARS" ]; then
#              echo "Processing vars..."
#              process_env_vars "$ALLMYVARS" "$branch_prefix" "$BUILD_ARGS_FILE"
#            fi
#
#            # Add package manager
#            echo "PACKAGE_MANAGER=pnpm" >> "$BUILD_ARGS_FILE"
#
#            # Debug output (without showing sensitive values)
#            echo "Generated build args file with $(wc -l < "$BUILD_ARGS_FILE") variables"
#            echo "Dockerfile path: $dockerfile_path"
#            echo "Build context: $build_context"
#            # Create Docker build command with proper escaping
#            DOCKER_CMD="docker buildx build --push "
#
#            # Check if branch name is dev or sandbox
#            #
#            #            if  [ "$branch_name" == "dev" ] || [ "$branch_name" == "sandbox" ]; then
#            #              echo "Branch is $branch_name. Building with target development."
#            #              DOCKER_CMD+=" --target development "
#            #            else
#            #              echo "Branch is $branch_name. Building with default (production) target."
#            #              DOCKER_CMD+=" --target production "
#            #            fi
#            DOCKER_CMD+=" --target production "
#            # Add build args from file
#            while IFS='=' read -r key value; do
#              if [ -n "$key" ]; then
#                DOCKER_CMD+="--build-arg $key=\"$value\" "
#              fi
#            done < "$BUILD_ARGS_FILE"
#
#            # Add remaining arguments
#            DOCKER_CMD+=" -f \"$dockerfile_path\""
#            DOCKER_CMD+=" -t \"$tag_commit\""
#            DOCKER_CMD+=" -t \"$tag_latest\""
#            DOCKER_CMD+=" \"$build_context\""
#
#
#            # Execute build
#            echo "Starting docker build..."
#            if ! eval "$DOCKER_CMD"; then
#              echo "Retrying without cache due to potential dependency issues..."
#              eval "$DOCKER_CMD --no-cache"
#            fi
#
#            # Cleanup
#            rm -f "$BUILD_ARGS_FILE"
#          else
#            echo "Error: Dockerfile $dockerfile_path does not exist. Skipping $service."
#          fi
#      - name: Send Telegram Message - Build Success
#        if: success()
#        env:
#          TELEGRAM_BOT_TOKEN: ${{ vars.TELEGRAM_BOT_TOKEN_FOR_DEPLOYMENT }}
#          TELEGRAM_CHAT_ID: ${{ vars.TELEGRAM_CHAT_ID_FOR_DEPLOYMENT }}
#        run: |
#          if [ -z "$TELEGRAM_BOT_TOKEN" ] || [ -z "$TELEGRAM_CHAT_ID" ]; then
#            echo "Error: Telegram vars are not set or are empty."
#            exit 1
#          fi
#
#          curl -s -X POST "https://api.telegram.org/bot$TELEGRAM_BOT_TOKEN/sendMessage" \
#            -d chat_id="$TELEGRAM_CHAT_ID" \
#            -d text="
#            Hi there!
#            ðŸ”„ Build was successful for ${{ github.repository }}
#
#            ðŸ“ branch: ${{ github.ref }}
#
#            ðŸ§‘ â€ðŸ’»Actor: ${{ github.actor }}
#
#            ðŸ–Š   message: ${{ github.event.head_commit.message }}
#
#            ðŸ” See Changes: https://github.com/${{ github.repository }}/commit/${{ github.sha }}"
#      - name: Send Telegram Message - Build Failure
#        if: failure()
#        continue-on-error: true
#        env:
#          TELEGRAM_BOT_TOKEN: ${{ vars.TELEGRAM_BOT_TOKEN_FOR_DEPLOYMENT }}
#          TELEGRAM_CHAT_ID: ${{ vars.TELEGRAM_CHAT_ID_FOR_DEPLOYMENT }}
#        run: |
#
#          if [ -z "$TELEGRAM_BOT_TOKEN" ] || [ -z "$TELEGRAM_CHAT_ID" ]; then
#            echo "Error: Telegram vars are not set or are empty."
#            exit 1
#          fi
#
#          curl -s -X POST "https://api.telegram.org/bot$TELEGRAM_BOT_TOKEN/sendMessage" \
#            -d chat_id="$TELEGRAM_CHAT_ID" \
#            -d text="
#            Hi there!
#            ðŸ”„ Build was NOT successful for ${{ github.repository }}
#
#            ðŸ“ branch: ${{ github.ref }}
#
#            ðŸ§‘ â€ðŸ’»Actor: ${{ github.actor }}
#
#            ðŸ–Š   message: ${{ github.event.head_commit.message }}
#
#            âŒ âŒ Build failed âŒ âŒ
#
#            ðŸ” See Changes: https://github.com/${{ github.repository }}/commit/${{ github.sha }}"
  deploy:
    runs-on: ubuntu-latest
    needs: [determine-services] #, build-and-push
    if: ${{ needs.determine-services.outputs.services_to_build != '[]' }}
    permissions:
      contents: write
      packages: read
      actions: write
      id-token: write

    env:
      ALLMYSECRETS: ${{ toJSON(secrets) }}
      ALLMYVARS: ${{ toJSON(vars) }}
    steps:
      - name: Authenticate to GitHub Container Registry
        env:
          CR_PAT: ${{ secrets.GITHUB_TOKEN }}
        run: echo "${CR_PAT}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
      - name: Start SSH Agent and Add Key
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}
      - name: Checkout Code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Authenticate to GitHub Container Registry
        env:
          CR_PAT: ${{ secrets.GITHUB_TOKEN }}
        run: echo "${CR_PAT}" | docker login ghcr.io -u ${{ github.actor }} --password-stdin
      - name: Generate Environment Variables .env File
        id: generate-env-script
        env:
          CR_PAT: ${{ secrets.GITHUB_TOKEN }}
        run: |
          branch_name="${{ github.ref_name }}"
          prefix="${branch_name^^}_"
          github_repo=$(echo "${{ github.repository }}" | tr '[:upper:]' '[:lower:]')
          env_file=".env"
          
          echo "Generating environment variables script for prefix: $prefix"
          
          # Create or truncate the env file if it already exists
          > $env_file
          
          # Extract GitHub secrets and environment variables from ALLMYSECRETS and ALLMYVARS
          secrets_json="${ALLMYSECRETS}"
          vars_json="${ALLMYVARS}"
          
          # Parse the JSON and filter the variables with the appropriate prefix, removing the prefix when writing to the env file
          echo "$secrets_json" | jq -r --arg prefix "$prefix" \
            'to_entries[] | select(.key | startswith($prefix)) | "\(.key[$prefix | length:])=\"\(.value)\""' >> $env_file
          
          echo "$vars_json" | jq -r --arg prefix "$prefix" \
            'to_entries[] | select(.key | startswith($prefix)) | "\(.key[$prefix | length:])=\"\(.value)\""' >> $env_file
          
          # Add branch name as env also
          echo "BRANCH_NAME=\"$branch_name\"" >> $env_file
          # Add github repo as env also
          echo "GITHUB_REPO=\"$github_repo\"" >> $env_file
          # Add the GitHub Container Registry PAT to the env file
          echo "CR_PAT=\"${CR_PAT}\"" >> $env_file
          
          echo "Environment variables script generated successfully."
 

      - name: Set up SSH Environment Variables
        id: set-env-vars
        run: |
          echo "Setting up SSH environment variables..."
          branch_name="${{ github.ref_name }}"

          # Use case-insensitive prefix matching for branch name
          if [[ "$branch_name" == "dev" ]]; then
            echo "SSH_IP=${{ secrets.SSH_DEV_IP }}" >> $GITHUB_ENV
            echo "SSH_PORT=${{ secrets.SSH_DEV_PORT }}" >> $GITHUB_ENV
          elif [[ "$branch_name" == "staging" ]]; then
            echo "SSH_IP=${{ secrets.SSH_STAGE_IP }}" >> $GITHUB_ENV
            echo "SSH_PORT=${{ secrets.SSH_STAGE_PORT }}" >> $GITHUB_ENV
          elif [[ "$branch_name" == "sandbox" ]]; then
            echo "SSH_IP=${{ secrets.SSH_SANDBOX_IP }}" >> $GITHUB_ENV
            echo "SSH_PORT=${{ secrets.SSH_SANDBOX_PORT }}" >> $GITHUB_ENV
          elif [[ "$branch_name" == "main" ]]; then
            echo "SSH_IP=${{ secrets.SSH_SANDBOX_PORT }}" >> $GITHUB_ENV
            echo "SSH_PORT=${{ secrets.SSH_SANDBOX_PORT }}" >> $GITHUB_ENV
          else
            echo "Error: Unknown branch name, unable to set SSH credentials."
            exit 1
          fi
      - name: Authenticate to GitHub Container Registry on Remote Server
        run: |
          echo "Authenticating to GitHub Container Registry..."
          branch_name="${{ github.ref_name }}"
          ssh_ip="${SSH_IP}"
          echo "Deploying services to branch: $branch_name"
          if [ -z "$ssh_ip" ]; then
            echo "Error: SSH IP not found."
            exit 1
          fi

      - name: Deploy Changed Services
        env:
          CR_PAT: ${{ secrets.GITHUB_TOKEN }}
        run: |
          ls -la
          
          branch_name="${{ github.ref_name }}"
          ssh_ip="${SSH_IP}"
          ssh_port="${SSH_PORT}"
          services_to_build=${{ needs.determine-services.outputs.services_to_build }}   
          echo "changed services: $services_to_build"
          echo "Deploying services to branch: $branch_name"
          if [ -z "$ssh_ip" ]; then
            echo "Error: SSH IP not found."
            exit 1
          fi

          echo "Connecting to server and creating branch directory..."

          # Use case-insensitive prefix matching for branch name
          # [[ "$branch_name" == "dev" ]] ||
          if [[ "$branch_name" == "sandbox" ]]; then
            ssh -o StrictHostKeyChecking=no -p "$ssh_port" tonont@$ssh_ip  << EOF
            mkdir -p /home/tonont/$branch_name
            mkdir -p /home/tonont/$branch_name/mini-app
            mkdir -p /home/tonont/$branch_name/mini-app-cron
            mkdir -p /home/tonont/$branch_name/telegram-bot
            mkdir -p /home/tonont/$branch_name/client-web
            mkdir -p /home/tonont/$branch_name/participant-tma
            mkdir -p /home/tonont/$branch_name/nft-microservice
            mkdir -p /home/tonont/$branch_name/website
            EOF
          else
            ssh -o StrictHostKeyChecking=no -p "$ssh_port" tonont@$ssh_ip << EOF
            mkdir -p /home/tonont/$branch_name
          EOF
          fi

          echo "Copying files to server..."
          scp  -P "$ssh_port"  -r -o StrictHostKeyChecking=no docker-compose-server.yml .env docker-compose-server.volume.dev.yml docker-compose-server.override.dev.yml .dockerignore  devops tonont@$ssh_ip:/home/tonont/$branch_name
          
          
          # Remove brackets and convert to space-separated string
          services=$(echo "$services_to_build" | tr -d '[]"' | tr ',' ' ')
          echo "Formatted services to build: $services"  # Debug output        
          ssh -p "$ssh_port" -o StrictHostKeyChecking=no tonont@$ssh_ip << EOF
            whoami
            echo "Loading environment variables..."
            cd /home/tonont/$branch_name
            source .env
            echo "******Logging into GitHub Container Registry..."
            if [ -z "$CR_PAT" ]; then
              echo "CR_PAT is not set or is empty"; exit 1;
            fi
             
            echo "services to build: $services_to_build"
            # Remove the square brackets and split by comma
            echo "Pulling latest images of changed services..."
            for service in $services; do
              echo "Processing service: \$service"
              if [ -z "\$service" ]; then
                echo "Warning: Found an empty service name, skipping..."
              else
                echo "Pulling Docker image for service: \$service"
                docker pull ghcr.io/pomegroup/ontonbot/\${service}:${branch_name}-latest
              fi
            done
          EOF
          echo "Exporting all environment variables with branch-specific prefix..."
          ssh  -p "$ssh_port" -o StrictHostKeyChecking=no tonont@$ssh_ip << EOF
            echo "Listing files in branch directory..."        
            cd /home/tonont/$branch_name
            ls -la
            echo "Sourcing .env file..."
            set -o allexport
            source .env
            set +o allexport
            cd /home/tonont/$branch_name
            source /home/tonont/$branch_name/.env
            chmod +x devops/generate-caddyfile.sh
            chmod +x devops/minio-init.sh
            echo "Updating Docker node label for stage $branch_name..."
            docker node update --label-add stage.$branch_name=true ontonServer
            echo "Deploying Docker stack for $branch_name..."
            docker stack deploy --with-registry-auth -c docker-compose-server.yml $branch_name

            echo "Forcing update of services..."
            services=\$(echo "$services_to_build" | tr -d '[]"' | tr ',' ' ')
            for service in $services; do
              echo " branch name: $branch_name"
              echo " service: \$service"
              full_service_name= "\$branch_name_\$service"
              echo "docker service update --force \$full_service_name"
              docker service update --force  \$full_service_name
            done

          
          EOF

          echo "Services deployed successfully."
      - name: Cleanup Environment Variables File
        if: always()
        run: |
          echo "Cleaning up environment variables script..."
          #rm -f .env
          echo "Environment variables script deleted successfully."

      - name: Send Telegram Message - Deployment Success
        if: success()
        continue-on-error: true
        env:
          TELEGRAM_BOT_TOKEN: ${{ vars.TELEGRAM_BOT_TOKEN_FOR_DEPLOYMENT }}
          TELEGRAM_CHAT_ID: ${{ vars.TELEGRAM_CHAT_ID_FOR_DEPLOYMENT }}
        run: |
          if [ -z "$TELEGRAM_BOT_TOKEN" ] || [ -z "$TELEGRAM_CHAT_ID" ]; then
            echo "Error: Telegram vars are not set or are empty."
            exit 1
          fi

          curl -s -X POST "https://api.telegram.org/bot$TELEGRAM_BOT_TOKEN/sendMessage" \
            -d chat_id="$TELEGRAM_CHAT_ID" \
            -d text="
            Hi there! 
            ðŸ”„ Build Started for ${{ github.repository }}
          
            ðŸ§‘ â€ðŸ’»Actor: ${{ github.actor }}
            ðŸ“ branch: ${{ github.ref }}
          
            ðŸ–Š   message: ${{ github.event.head_commit.message }}
          
            âœ… deployment completed successfully
            "
      - name: Send Telegram Message - Deployment Failure
        if: failure()
        env:
          TELEGRAM_BOT_TOKEN: ${{ vars.TELEGRAM_BOT_TOKEN_FOR_DEPLOYMENT }}
          TELEGRAM_CHAT_ID: ${{ vars.TELEGRAM_CHAT_ID_FOR_DEPLOYMENT }}
        run: |
          if [ -z "$TELEGRAM_BOT_TOKEN" ] || [ -z "$TELEGRAM_CHAT_ID" ]; then
            echo "Error: Telegram vars are not set or are empty."
            exit 1
          fi

          curl -s -X POST "https://api.telegram.org/bot$TELEGRAM_BOT_TOKEN/sendMessage" \
            -d chat_id="$TELEGRAM_CHAT_ID" \
            -d text="
            Hi there! 
            ðŸ”„ Build Started for ${{ github.repository }}
          
            ðŸ§‘ â€ðŸ’»Actor: ${{ github.actor }}
          
            ðŸ–Š   message: ${{ github.event.head_commit.message }}
            
            ðŸ“ branch: ${{ github.ref }}
            
            âŒ âŒ deployment failed âŒ âŒ 
            "
