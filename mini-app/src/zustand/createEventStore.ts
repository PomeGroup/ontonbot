import { GeneralFormErrors, RewardFormErrors, TimePlaceFormErorrs } from "@/app/_components/Event/steps/types";
import { EventDataSchemaAllOptional, PaidEventType } from "@/types";
import { create } from "zustand";
import { devtools } from "zustand/middleware";
import { immer } from "zustand/middleware/immer";
import type {} from "@redux-devtools/extension"; // required for devtools typing
import { Address } from "@ton/core";

export type StoreEventData = Omit<EventDataSchemaAllOptional, "paid_event"> & {
  /*
   * These types are generated by event store And are dynamic
   */
  hasEnded: boolean;

  /*
   * These type are corrected to work with the schema
   */
  paid_event: Partial<PaidEventType>;
};

type PaymentType = "USDT" | "TON";

export type CreateEventStoreType = {
  currentStep: number;
  setCurrentStep: (_step: number) => void;
  eventData: StoreEventData;
  edit?: {
    eventHash?: string;
  };
  setEventData: (_data: Partial<StoreEventData>) => void;
  setEdit: (_edit: { eventHash?: string }) => void;
  resetState: () => void;
  // form errors
  generalStepErrors?: GeneralFormErrors;
  timeplaceStepErrors?: TimePlaceFormErorrs;
  rewardStepErrors?: RewardFormErrors;
  // set errors
  setGeneralStepErrors: (_: GeneralFormErrors) => void;
  setTimePlaceStepErrors: (_: TimePlaceFormErorrs) => void;
  setRewardStepErrors: (_: RewardFormErrors) => void;
  // clear errors
  clearGeneralStepErrors: () => void;
  clearRewardStepErrors: () => void;
  clearTimePlaceStepErrors: () => void;
  clearImageErrors: () => void;
  resetReward: () => void;

  // PAID EVENT CREATION ACTIONS
  togglePaidEvent: () => void;
  changePaymentType: (_: PaymentType) => void;
  changePaymentAmount: (_: number) => void;
  changeRecepientAddress: (_: string) => void;
  // --- // nft info
  changeNFTImage: (_: string) => void;
  changeNFTTitle: (_title: string) => void;
  changeNFTDescription: (_desc: string) => void;
};

const defaultState = {
  event: {
    dynamic_fields: [],
    owner: 0,
    type: 0,
    hasEnded: true,
    has_registration: false,
    has_approval: false,
    has_waiting_list: false,
    capacity: null,
    paid_event: {
      has_payment: false,
    },
  },
  step: 1,
};

export const useCreateEventStore = create<CreateEventStoreType>()(
  devtools(
    immer((set) => ({
      currentStep: defaultState.step,
      eventData: defaultState.event,
      clearImageErrors: () => {
        set((state) => ({
          ...state,
          generalStepErrors: { ...state.generalStepErrors, image_url: undefined },
        }));
      },
      setGeneralStepErrors: (errors) => {
        set((state) => ({
          ...state,
          generalStepErrors: errors,
        }));
      },
      setTimePlaceStepErrors(errors) {
        set((state) => ({
          ...state,
          timeplaceStepErrors: errors,
        }));
      },
      setRewardStepErrors: (errors) => {
        set((state) => ({
          ...state,
          rewardStepErrors: errors,
        }));
      },
      clearGeneralStepErrors: () => {
        set((state) => {
          return {
            ...state,
            generalStepErrors: {},
          };
        });
      },
      clearTimePlaceStepErrors() {
        set((state) => {
          return {
            ...state,
            timeplaceStepErrors: {},
          };
        });
      },
      clearRewardStepErrors: () => {
        set((state) => ({
          ...state,
          rewardStepErrors: {},
        }));
      },
      setCurrentStep: (step: number) => set((state) => ({ ...state, currentStep: step })),
      setEventData: (data) =>
        set((state) => {
          const newData = {
            ...state.eventData,
            ...data,
          };

          state.eventData = newData;
          state.eventData.hasEnded = !!(state.edit?.eventHash && state?.eventData?.end_date && state.eventData.end_date < Date.now() / 1000);
        }),
      setEdit: (edit: { eventHash?: string }) => set((state) => ({ ...state, edit })),

      resetState: () => {
        set(() => ({
          currentStep: defaultState.step,
          eventData: defaultState.event,
          edit: {},
        }));
      },
      resetReward: () => {
        set((state) => ({
          ...state,
          eventData: {
            capacity: null,
            has_waiting_list: false,
            has_approval: false,
            has_registration: false,
            ...state.eventData,
            video_url: "",
            ts_reward_url: "",
          },
        }));
      },
      togglePaidEvent: () => {
        set((state) => {
          const paidEventInfo = {
            has_payment: !state.eventData?.paid_event?.has_payment,
            has_nft: true,
            payment_type: "TON",
            payment_amount: 1,
          } as Partial<PaidEventType>;

          /*
           * Handle Confirmation and Notifying user that they need to pay to create a paid event
           */
          if (!state.eventData.paid_event.has_payment) {
            window.Telegram.WebApp.showConfirm(
              "You will need pay 10 TON to create a paid event + 0.055 TON for each person buying the ticket (minting fees)",
              (confirmed) => {
                if (confirmed) {
                  set((state) => {
                    state.eventData.paid_event = paidEventInfo;
                  });
                }
              }
            );
          } else {
            state.eventData.paid_event = paidEventInfo;
          }
        });
      },
      changePaymentType(payment_type) {
        set((state) => {
          state.eventData.paid_event.payment_type = payment_type;
          state.eventData.paid_event.payment_amount = payment_type === "USDT" ? 5 : 1;
        });
      },
      changePaymentAmount(amount) {
        set((state) => {
          state.eventData.paid_event.payment_amount = amount;
        });
      },
      changeRecepientAddress(address) {
        set((state) => {
          try {
            Address.parse(address);
            state.eventData.paid_event.payment_recipient_address = address;
          } catch (error) {
            // handle error here
            state.eventData.paid_event.payment_recipient_address = "";
          }
        });
      },
      changeNFTImage(image) {
        set((state) => {
          state.eventData.paid_event.nft_image_url = image;
        });
      },
      changeNFTTitle: (title) => {
        set((state) => {
          state.eventData.paid_event.nft_title = title;
        });
      },
      changeNFTDescription: (desc) => {
        set((state) => {
          state.eventData.paid_event.nft_description = desc;
        });
      },
    }))
  )
);
