import { GeneralFormErrors, RewardFormErrors, TimePlaceFormErorrs } from "@/app/_components/Event/steps/types";
import { EventDataSchemaAllOptional, PaidEventSchema, PaidEventType } from "@/types";
import { create } from "zustand";
import { devtools } from "zustand/middleware";
import { immer } from "zustand/middleware/immer";
import type {} from "@redux-devtools/extension"; // required for devtools typing
import { Address } from "@ton/core";

export type StoreEventData = Omit<EventDataSchemaAllOptional, "paid_event"> & {
  /*
   * These types are generated by event store And are dynamic
   */
  hasEnded: boolean;

  /*
   * These type are corrected to work with the schema
   */
  paid_event: Partial<PaidEventType>;
};

type PaymentType = "USDT" | "TON";

type PaidInfoErrors = {
  has_payment?: string[] | undefined;
  payment_recipient_address?: string[] | undefined;
  payment_type?: string[] | undefined;
  payment_amount?: string[] | undefined;
  has_nft?: string[] | undefined;
  nft_title?: string[] | undefined;
  nft_description?: string[] | undefined;
  nft_image_url?: string[] | undefined;
  capacity?: string[] | undefined;
};

export type CreateEventStoreType = {
  currentStep: number;
  setCurrentStep: (_step: number) => void;
  eventData: StoreEventData;
  edit?: {
    eventHash?: string;
  };
  setEventData: (_data: Partial<StoreEventData>) => void;
  setEdit: (_edit: { eventHash?: string }) => void;
  resetState: () => void;

  // form errors
  generalStepErrors?: GeneralFormErrors;
  timeplaceStepErrors?: TimePlaceFormErorrs;
  rewardStepErrors?: RewardFormErrors;

  // set errors
  setGeneralStepErrors: (_: GeneralFormErrors) => void;
  setTimePlaceStepErrors: (_: TimePlaceFormErorrs) => void;
  setRewardStepErrors: (_: RewardFormErrors) => void;

  // clear errors
  clearGeneralStepErrors: () => void;
  clearRewardStepErrors: () => void;
  clearTimePlaceStepErrors: () => void;
  clearImageErrors: () => void;
  resetReward: () => void;

  // REGISTRATION
  toggleHasRegistration: () => void;

  /**
   * PAID EVENT CREATION ACTIONS
   */
  togglePaidEvent: () => void;
  changePaymentType: (_: PaymentType) => void;
  changePaymentAmount: (_: number) => void;
  changeRecepientAddress: (_: string) => void;
  // --- // nft info
  changeNFTImage: (_: string) => void;
  changeNFTTitle: (_title: string) => void;
  changeNFTDescription: (_desc: string) => void;

  /**** REGISTRATION STEP MAIN BUTTON CLICK ****/
  registrationStepMainButtonClick: () => void;

  /**** ⭕ PAID EVENT INPUT ERRORS ⭕ ****/
  paid_info_errors: PaidInfoErrors;
  setPaidInfoErrors: (_key: keyof PaidInfoErrors, _value: any) => void;
};

const defaultState = {
  event: {
    dynamic_fields: [],
    owner: 0,
    type: 0,
    hasEnded: true,
    has_registration: false,
    has_approval: false,
    has_waiting_list: false,
    capacity: null,
    paid_event: {
      has_payment: false,
    },
  },
  step: 1,
};

export const useCreateEventStore = create<CreateEventStoreType>()(
  devtools(
    immer((set, get) => ({
      currentStep: defaultState.step,
      eventData: defaultState.event,
      paid_info_errors: {},
      clearImageErrors: () => {
        set((state) => ({
          ...state,
          generalStepErrors: { ...state.generalStepErrors, image_url: undefined },
        }));
      },
      setGeneralStepErrors: (errors) => {
        set((state) => ({
          ...state,
          generalStepErrors: errors,
        }));
      },
      setTimePlaceStepErrors(errors) {
        set((state) => ({
          ...state,
          timeplaceStepErrors: errors,
        }));
      },
      setRewardStepErrors: (errors) => {
        set((state) => ({
          ...state,
          rewardStepErrors: errors,
        }));
      },
      clearGeneralStepErrors: () => {
        set((state) => {
          return {
            ...state,
            generalStepErrors: {},
          };
        });
      },
      clearTimePlaceStepErrors() {
        set((state) => {
          return {
            ...state,
            timeplaceStepErrors: {},
          };
        });
      },
      clearRewardStepErrors: () => {
        set((state) => ({
          ...state,
          rewardStepErrors: {},
        }));
      },
      setCurrentStep: (step: number) => set((state) => ({ ...state, currentStep: step })),
      setEventData: (data) =>
        set((state) => {
          const newData = {
            ...state.eventData,
            ...data,
          };

          state.eventData = newData;
          state.eventData.hasEnded = !!(state.edit?.eventHash && state?.eventData?.end_date && state.eventData.end_date < Date.now() / 1000);
        }),
      setEdit: (edit: { eventHash?: string }) => set((state) => ({ ...state, edit })),

      resetState: () => {
        set(() => ({
          currentStep: defaultState.step,
          eventData: defaultState.event,
          edit: {},
        }));
      },
      resetReward: () => {
        set((state) => ({
          ...state,
          eventData: {
            capacity: null,
            has_waiting_list: false,
            has_approval: false,
            has_registration: false,
            ...state.eventData,
            video_url: "",
            ts_reward_url: "",
          },
        }));
      },
      toggleHasRegistration: () => {
        set((state) => {
          state.eventData.has_registration = !state.eventData.has_registration;
          if (state.eventData.has_registration) {
            state.eventData.paid_event.has_payment = false;
            state.eventData.capacity = null;
          }
        });
      },
      togglePaidEvent: () => {
        set((state) => {
          const paidEventInfo = {
            has_payment: !state.eventData?.paid_event?.has_payment,
            has_nft: true,
            payment_type: "TON",
            payment_amount: 1,
          } as Partial<PaidEventType>;

          /*
           * Handle Confirmation and Notifying user that they need to pay to create a paid event
           */
          if (!state.eventData.paid_event.has_payment) {
            try {
              window.Telegram.WebApp.showConfirm(
                "You will need pay 10 TON to create a paid event + 0.055 TON for each person buying the ticket (minting fees)",
                (confirmed) => {
                  if (confirmed) {
                    set((state) => {
                      state.eventData.paid_event = paidEventInfo;
                      state.eventData.has_registration = false;
                    });
                  }
                }
              );
            } catch {
              state.eventData.paid_event = paidEventInfo;
              state.eventData.has_registration = false;
            }

            state.eventData.capacity = 5;
          } else {
            state.eventData.paid_event = paidEventInfo;
            state.eventData.capacity = null;
          }
        });
      },
      changePaymentType(payment_type) {
        set((state) => {
          state.eventData.paid_event.payment_type = payment_type;
          state.eventData.paid_event.payment_amount = payment_type === "USDT" ? 5 : 1;
        });
      },
      changePaymentAmount(amount) {
        set((state) => {
          state.eventData.paid_event.payment_amount = amount;
        });
      },
      changeRecepientAddress(address) {
        set((state) => {
          try {
            Address.parse(address);
            state.eventData.paid_event.payment_recipient_address = address;
          } catch (error) {
            // handle error here
            state.eventData.paid_event.payment_recipient_address = "";
          }
        });
      },
      changeNFTImage(image) {
        set((state) => {
          state.eventData.paid_event.nft_image_url = image;
        });
      },
      changeNFTTitle: (title) => {
        set((state) => {
          state.eventData.paid_event.nft_title = title;
        });
      },
      changeNFTDescription: (desc) => {
        set((state) => {
          state.eventData.paid_event.nft_description = desc;
        });
      },
      setPaidInfoErrors: (key, value) => {
        set((state) => {
          state.paid_info_errors[key] = value;
        });
      },
      registrationStepMainButtonClick: () => {
        const hasPayment = get().eventData.paid_event.has_payment;
        if (hasPayment) {
          const paymentParsed = PaidEventSchema.safeParse(get().eventData.paid_event);
          if (paymentParsed.error) {
            set((state) => {
              state.paid_info_errors = paymentParsed.error.flatten().fieldErrors;
            });
          } else if (paymentParsed.success) {
            get().setCurrentStep(4);
            set((state) => {
              state.paid_info_errors = {};
            });
          }
        }
      },
    }))
  )
);
