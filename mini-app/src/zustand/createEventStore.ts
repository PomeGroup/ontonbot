import { AttendanceFormErrors, GeneralFormErrors } from "@/app/_components/Event/steps/types";
import { EventTicketType } from "@/db/schema";
import { EventDataSchemaAllOptional, PaidEventSchema, PaidEventType } from "@/types";
import type {} from "@redux-devtools/extension";
import { create } from "zustand";
import { devtools } from "zustand/middleware";
import { immer } from "zustand/middleware/immer";
// required for devtools typing

export type StoreEventData = Omit<EventDataSchemaAllOptional, "paid_event"> & {
  /*
   * These types are generated by event store And are dynamic
   */
  hasEnded: boolean;

  /*
   * These type are corrected to work with the schema
   */
  paid_event: Partial<PaidEventType> & {
    bought_capacity?: number;
  };

  /*
   * SBT type
   */
  reward: {
    type: SBTRewardType;
  };
};

export type SBTRewardType = "default" | "custom";

export type PaymentType = "USDT" | "TON" | "STAR";

export type CreateEventStoreType = {
  currentStep: number;
  setCurrentStep: (_step: number) => void;
  eventData: StoreEventData;
  edit?: {
    eventHash?: string;
  };

  setEventData: (_data: Partial<StoreEventData>) => void;
  setEdit: (_edit: { eventHash?: string }) => void;
  resetState: () => void;

  // form errors
  generalStepErrors?: GeneralFormErrors;
  attendanceStepErrors?: AttendanceFormErrors;

  // set errors
  setGeneralStepErrors: (_: GeneralFormErrors) => void;
  setAttendanceStepErrors: (_: AttendanceFormErrors) => void;

  // clear errors
  clearGeneralStepErrors: () => void;
  clearAttendanceStepErrors: () => void;
  clearImageErrors: () => void;
  clearVideoErrors: () => void;
  resetReward: () => void;

  // REGISTRATION
  toggleHasRegistration: () => void;

  /**
   * PAID EVENT CREATION ACTIONS
   */
  togglePaidEvent: () => void;
  changePaymentType: (paymentType: PaymentType) => void;
  changeTicketType: (ticketType: EventTicketType) => void;

  /**** REGISTRATION STEP MAIN BUTTON CLICK ****/
  registrationStepMainButtonClick: (_recipient: string | null) => void;

  /* Reward Type */
  setRewardType: (rewardType: SBTRewardType) => void;
};

const defaultState = {
  event: {
    dynamic_fields: [] as {
      type: string;
      title: string;
      description: string;
      emoji: string;
      id?: number | undefined;
      placeholder?: string | undefined;
      url?: string | undefined;
    }[],
    owner: 0,
    type: 0,
    hasEnded: true,
    has_registration: false,
    has_approval: false,
    has_waiting_list: false,
    capacity: 100,
    timezone: Intl.DateTimeFormat().resolvedOptions().timeZone,
    paid_event: {
      has_payment: false,
    },
    eventLocationType: "online" as const,
    reward: {
      type: "default" as const,
    },
  },
  step: 1,
};

export const useCreateEventStore = create<CreateEventStoreType>()(
  devtools(
    immer((set, get) => ({
      currentStep: defaultState.step,
      eventData: defaultState.event,
      paid_info_errors: {},

      /*
       * Set sbt reward type
       */
      setRewardType: (rewardType: SBTRewardType) => {
        set((state) => {
          state.eventData.reward.type = rewardType;
        });
      },

      clearImageErrors: () => {
        set((state) => ({
          ...state,
          generalStepErrors: { ...state.generalStepErrors, image_url: undefined },
        }));
      },
      clearVideoErrors: () => {
        set((state) => ({
          ...state,
          generalStepErrors: { ...state.generalStepErrors, video_url: undefined },
        }));
      },
      setGeneralStepErrors: (errors) => {
        set((state) => {
          // WE ONLY WANT TO SET THE ERRORS THAT ARE RELATED TO GENERAL STEP
          // extra keys will be ignored
          const errorsData: GeneralFormErrors = {
            title: errors.title,
            subtitle: errors.subtitle,
            description: errors.description,
            image_url: errors.image_url,
            society_hub: errors.society_hub,
            has_registration: errors.has_registration,
            has_approval: errors.has_approval,
            capacity: errors.capacity,
            category_id: errors.category_id,
            start_date: errors.start_date,
            end_date: errors.end_date,
            timezone: errors.timezone,
            duration: errors.duration,
            location: errors.location,
            cityId: errors.cityId,
            countryId: errors.countryId,
          };

          state.generalStepErrors = errorsData;
        });
      },
      setAttendanceStepErrors: (errors) => {
        set((state) => {
          // WE ONLY WANT TO SET THE ERRORS THAT ARE RELATED TO ATTENDANCE STEP
          // extra keys will be ignored
          const errorsData: AttendanceFormErrors = {
            secret_phrase: errors.secret_phrase,
            ts_reward_url: errors.ts_reward_url,
            video_url: errors.video_url,
          };

          state.attendanceStepErrors = errorsData;
        });
      },
      clearGeneralStepErrors: () => {
        set((state) => {
          return {
            ...state,
            generalStepErrors: {},
          };
        });
      },
      clearAttendanceStepErrors: () => {
        set((state) => ({
          ...state,
          attendanceStepErrors: {},
        }));
      },
      setCurrentStep: (step: number) => set((state) => ({ ...state, currentStep: step })),
      setEventData: (data) =>
        set((state) => {
          const newData = {
            ...state.eventData,
            ...data,
          };

          if (newData.eventLocationType === "in_person") {
            newData.has_registration = true;
          }

          if (data.countryId) {
            newData.cityId = undefined;
          }

          state.eventData = newData;
          state.eventData.hasEnded = !!(
            state.edit?.eventHash &&
            state?.eventData?.end_date &&
            state.eventData.end_date < Date.now() / 1000
          );
        }),
      setEdit: (edit: { eventHash?: string }) => set((state) => ({ ...state, edit })),

      resetState: () => {
        set(() => ({
          currentStep: defaultState.step,
          eventData: defaultState.event,
          edit: {},
        }));
      },
      resetReward: () => {
        set((state) => ({
          ...state,
          eventData: {
            capacity: null,
            has_waiting_list: false,
            has_approval: false,
            has_registration: false,
            ...state.eventData,
            video_url: "",
            ts_reward_url: "",
          },
        }));
      },
      toggleHasRegistration: () => {
        set((state) => {
          const hasRegistrationValue =
            // if it's in person then we need to make true
            state.eventData.eventLocationType === "in_person" || !state.eventData.has_registration;

          state.eventData.has_registration = hasRegistrationValue;

          if (state.eventData.has_registration) {
            state.eventData.paid_event.has_payment = false;
            state.eventData.capacity = null;
          }
        });
      },
      togglePaidEvent: () => {
        set((state) => {
          const paidEventInfo = {
            has_payment: !state.eventData?.paid_event?.has_payment,
            has_nft: true,
            payment_type: "TON",
            ticket_type: "NFT",
            payment_amount: 1,
            payment_recipient_address: "",
          } as Partial<PaidEventType>;

          /*
           * Handle Confirmation and Notifying user that they need to pay to create a paid event
           */
          if (!state.eventData.paid_event?.has_payment) {
            try {
              window.Telegram.WebApp.showConfirm(
                "You will need to pay 10 TON to create a paid event if the ticket type is NFT it will include 0.06 TON for each person buying the ticket (minting fees) this does not include cSBT ticket type",
                (confirmed) => {
                  if (confirmed) {
                    set((state) => {
                      state.eventData.paid_event = {
                        ...paidEventInfo,
                        has_payment: Boolean(paidEventInfo.has_payment),
                        payment_recipient_address: paidEventInfo.payment_recipient_address || "",
                      };
                      state.eventData.has_registration = true;
                    });
                  }
                }
              );
            } catch {
              state.eventData.paid_event = {
                ...paidEventInfo,
                has_payment: Boolean(paidEventInfo.has_payment),
                payment_recipient_address: paidEventInfo.payment_recipient_address || "",
              };
              state.eventData.has_registration = true;
            }

            state.eventData.capacity = 5;
          } else {
            state.eventData.paid_event = {
              ...paidEventInfo,
              has_payment: Boolean(paidEventInfo.has_payment),
              payment_recipient_address: paidEventInfo.payment_recipient_address || "",
            };
            state.eventData.capacity = null;
          }
        });
      },
      changePaymentType(payment_type) {
        set((state) => {
          state.eventData.paid_event.payment_type = payment_type;
        });
      },
      changeTicketType(ticketType) {
        set((state) => {
          state.eventData.paid_event.ticket_type = ticketType;
        });
      },
      registrationStepMainButtonClick: () => {
        const { eventData, setCurrentStep } = get();
        const { paid_event, capacity } = eventData;

        const hasPayment = paid_event?.has_payment;

        if (hasPayment) {
          // Validate Paid Event Data
          const paymentParsed = PaidEventSchema.safeParse(paid_event);

          if (paymentParsed.error) {
            const fieldErrors = paymentParsed.error.flatten().fieldErrors;
            console.log("Validation Errors:", fieldErrors);
            set((state) => {
              if (state.attendanceStepErrors) {
                state.attendanceStepErrors.has_payment = fieldErrors.has_payment;
                state.attendanceStepErrors.payment_recipient_address = fieldErrors.payment_recipient_address;
                state.attendanceStepErrors.payment_type = fieldErrors.payment_type;
                state.attendanceStepErrors.ticket_type = fieldErrors.ticket_type;
              }
            });
          } else {
            // Validation successful, proceed to the next step
            set((state) => {
              if (state.attendanceStepErrors) {
                state.attendanceStepErrors.has_payment = undefined;
                state.attendanceStepErrors.payment_recipient_address = undefined;
                state.attendanceStepErrors.payment_type = undefined;
                state.attendanceStepErrors.ticket_type = undefined;
              }
            });
            console.log("Recipient Address:", paid_event.payment_recipient_address);
            console.log("Capacity:", capacity);
            setCurrentStep(4);
          }
        } else {
          // Handle Registration Only (No Payment)
          set((state) => {
            if (state.attendanceStepErrors) {
              state.attendanceStepErrors.has_payment = undefined;
              state.attendanceStepErrors.payment_recipient_address = undefined;
              state.attendanceStepErrors.payment_type = undefined;
              state.attendanceStepErrors.ticket_type = undefined;
            }
          });
          setCurrentStep(4);
        }
      },
    }))
  )
);
