import { GeneralFormErrors, RewardFormErrors, TimePlaceFormErorrs } from "@/app/_components/Event/steps/types";
import { EventTicketType } from "@/db/schema";
import { EventDataSchemaAllOptional, PaidEventSchema, PaidEventType } from "@/types";
import type {} from "@redux-devtools/extension";
import { create } from "zustand";
import { devtools } from "zustand/middleware";
import { immer } from "zustand/middleware/immer";
// required for devtools typing

export type StoreEventData = Omit<EventDataSchemaAllOptional, "paid_event"> & {
  /*
   * These types are generated by event store And are dynamic
   */
  hasEnded: boolean;

  /*
   * These type are corrected to work with the schema
   */
  paid_event: Partial<PaidEventType> & {
    bought_capacity?: number;
  };
};

type PaymentType = "USDT" | "TON" | "STAR";

type PaidInfoErrors = {
  has_payment?: string[] | undefined;
  payment_recipient_address?: string[] | undefined;
  payment_type?: string[] | undefined;
  payment_amount?: string[] | undefined;
  has_nft?: string[] | undefined;
  nft_title?: string[] | undefined;
  nft_description?: string[] | undefined;
  nft_image_url?: string[] | undefined;
  nft_video_url?: string[] | undefined;
  capacity?: string[] | undefined;
};

export type CreateEventStoreType = {
  currentStep: number;
  setCurrentStep: (_step: number) => void;
  eventData: StoreEventData;
  edit?: {
    eventHash?: string;
  };
  setEventData: (_data: Partial<StoreEventData>) => void;
  setEdit: (_edit: { eventHash?: string }) => void;
  resetState: () => void;

  // form errors
  generalStepErrors?: GeneralFormErrors;
  timeplaceStepErrors?: TimePlaceFormErorrs;
  rewardStepErrors?: RewardFormErrors;

  // set errors
  setGeneralStepErrors: (_: GeneralFormErrors) => void;
  setTimePlaceStepErrors: (_: TimePlaceFormErorrs) => void;
  setRewardStepErrors: (_: RewardFormErrors) => void;

  // clear errors
  clearGeneralStepErrors: () => void;
  clearRewardStepErrors: () => void;
  clearTimePlaceStepErrors: () => void;
  clearImageErrors: () => void;
  clearVideoErrors: () => void;
  resetReward: () => void;

  // REGISTRATION
  toggleHasRegistration: () => void;

  /**
   * PAID EVENT CREATION ACTIONS
   */
  togglePaidEvent: () => void;
  changePaymentType: (paymentType: PaymentType) => void;
  changeTicketType: (ticketType: EventTicketType) => void;
  changePaymentAmount: (amount: number) => void;
  // --- // nft info
  changeNFTImage: (url: string) => void;
  changeNFTVideo: (url: string) => void;
  changeNFTTitle: (title: string) => void;
  changeNFTDescription: (desc: string) => void;

  /**** REGISTRATION STEP MAIN BUTTON CLICK ****/
  registrationStepMainButtonClick: (_recipient: string | null) => void;

  /**** ⭕ PAID EVENT INPUT ERRORS ⭕ ****/
  paid_info_errors: PaidInfoErrors;
  setPaidInfoErrors: (_key: keyof PaidInfoErrors, _value: any) => void;
};

const defaultState = {
  event: {
    dynamic_fields: [] as {
      type: string;
      title: string;
      description: string;
      emoji: string;
      id?: number | undefined;
      placeholder?: string | undefined;
      url?: string | undefined;
    }[],
    owner: 0,
    type: 0,
    hasEnded: true,
    has_registration: false,
    has_approval: false,
    has_waiting_list: false,
    capacity: null,
    paid_event: {
      has_payment: false,
    },
  },
  step: 1,
};

export const useCreateEventStore = create<CreateEventStoreType>()(
  devtools(
    immer((set, get) => ({
      currentStep: defaultState.step,
      eventData: defaultState.event,
      paid_info_errors: {},
      clearImageErrors: () => {
        set((state) => ({
          ...state,
          generalStepErrors: { ...state.generalStepErrors, image_url: undefined },
        }));
      },
      clearVideoErrors: () => {
        set((state) => ({
          ...state,
          generalStepErrors: { ...state.generalStepErrors, video_url: undefined },
        }));
      },
      setGeneralStepErrors: (errors) => {
        set((state) => ({
          ...state,
          generalStepErrors: errors,
        }));
      },
      setTimePlaceStepErrors(errors) {
        set((state) => ({
          ...state,
          timeplaceStepErrors: errors,
        }));
      },
      setRewardStepErrors: (errors) => {
        set((state) => ({
          ...state,
          rewardStepErrors: errors,
        }));
      },
      clearGeneralStepErrors: () => {
        set((state) => {
          return {
            ...state,
            generalStepErrors: {},
          };
        });
      },
      clearTimePlaceStepErrors() {
        set((state) => {
          return {
            ...state,
            timeplaceStepErrors: {},
          };
        });
      },
      clearRewardStepErrors: () => {
        set((state) => ({
          ...state,
          rewardStepErrors: {},
        }));
      },
      setCurrentStep: (step: number) => set((state) => ({ ...state, currentStep: step })),
      setEventData: (data) =>
        set((state) => {
          const newData = {
            ...state.eventData,
            ...data,
          };

          state.eventData = newData;
          state.eventData.hasEnded = !!(
            state.edit?.eventHash &&
            state?.eventData?.end_date &&
            state.eventData.end_date < Date.now() / 1000
          );
        }),
      setEdit: (edit: { eventHash?: string }) => set((state) => ({ ...state, edit })),

      resetState: () => {
        set(() => ({
          currentStep: defaultState.step,
          eventData: defaultState.event,
          edit: {},
        }));
      },
      resetReward: () => {
        set((state) => ({
          ...state,
          eventData: {
            capacity: null,
            has_waiting_list: false,
            has_approval: false,
            has_registration: false,
            ...state.eventData,
            video_url: "",
            ts_reward_url: "",
          },
        }));
      },
      toggleHasRegistration: () => {
        set((state) => {
          state.eventData.has_registration = !state.eventData.has_registration;
          if (state.eventData.has_registration) {
            state.eventData.paid_event.has_payment = false;
            state.eventData.capacity = null;
          }
        });
      },
      togglePaidEvent: () => {
        set((state) => {
          const paidEventInfo = {
            has_payment: !state.eventData?.paid_event?.has_payment,
            has_nft: true,
            payment_type: "TON",
            ticket_type: "NFT",
            payment_amount: 1,
          } as Partial<PaidEventType>;

          /*
           * Handle Confirmation and Notifying user that they need to pay to create a paid event
           */
          if (!state.eventData.paid_event.has_payment) {
            try {
              window.Telegram.WebApp.showConfirm(
                "You will need to pay 10 TON to create a paid event if the ticket type is NFT it will include 0.06 TON for each person buying the ticket (minting fees) this does not include cSBT ticket type",
                (confirmed) => {
                  if (confirmed) {
                    set((state) => {
                      state.eventData.paid_event = paidEventInfo;
                      state.eventData.has_registration = true;
                    });
                  }
                }
              );
            } catch {
              state.eventData.paid_event = paidEventInfo;
              state.eventData.has_registration = true;
            }

            state.eventData.capacity = 5;
          } else {
            state.eventData.paid_event = paidEventInfo;
            state.eventData.capacity = null;
          }
        });
      },
      changePaymentType(payment_type) {
        set((state) => {
          state.eventData.paid_event.payment_type = payment_type;
          state.eventData.paid_event.payment_amount = payment_type === "USDT" ? 5 : 1;
        });
      },
      changePaymentAmount(amount: number) {
        const handledValue = isNaN(amount) ? undefined : amount < 0 ? Math.abs(amount) : amount;

        set((state) => {
          state.eventData.paid_event.payment_amount = handledValue;
        });
      },
      changeTicketType(ticketType) {
        set((state) => {
          state.eventData.paid_event.ticket_type = ticketType;
        });
      },
      changeNFTImage(image) {
        set((state) => {
          state.eventData.paid_event.nft_image_url = image;
        });
      },
      changeNFTVideo(video) {
        set((state) => {
          state.eventData.paid_event.nft_video_url = video;
        });
      },
      changeNFTTitle: (title) => {
        set((state) => {
          state.eventData.paid_event.nft_title = title;
        });
      },
      changeNFTDescription: (desc) => {
        set((state) => {
          state.eventData.paid_event.nft_description = desc;
        });
      },
      setPaidInfoErrors: (key, value) => {
        set((state) => {
          state.paid_info_errors[key] = value;
        });
      },
      registrationStepMainButtonClick: () => {
        const { eventData, setCurrentStep } = get();
        const { paid_event, capacity } = eventData;

        const hasPayment = paid_event?.has_payment;

        if (hasPayment) {
          // Validate Paid Event Data
          const paymentParsed = PaidEventSchema.safeParse({
            ...paid_event,
            payment_amount: Number(paid_event.payment_amount!),
          });

          if (paymentParsed.error) {
            const fieldErrors = paymentParsed.error.flatten().fieldErrors;
            console.log("Validation Errors:", fieldErrors);
            set((state) => {
              state.paid_info_errors = fieldErrors;
            });
          } else {
            // Validation successful, proceed to the next step
            set((state) => {
              state.paid_info_errors = {};
            });
            console.log("Recipient Address:", paid_event.payment_recipient_address);
            console.log("Capacity:", capacity);
            setCurrentStep(4);
          }
        } else {
          // Handle Registration Only (No Payment)
          set((state) => {
            state.paid_info_errors = {};
          });
          setCurrentStep(4);
        }
      },
    }))
  )
);
