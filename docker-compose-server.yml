x-common-extra-hosts: &default-extra-hosts
  extra_hosts:
    - host.docker.internal:host-gateway

x-common-env: &common-env
  ACME_AGREE: ${ACME_AGREE}
  BOT_TOKEN: ${BOT_TOKEN}
  CLIENT_WEB_DOMAIN: ${CLIENT_WEB_DOMAIN}
  DATABASE_URL: ${DATABASE_URL}
  DATABASE_URL_NFT_MANAGER: ${DATABASE_URL_NFT_MANAGER}
  ENV: ${ENV}
  GOLANG_SERVER_PORT: ${GOLANG_SERVER_PORT}
  IP_CLAMAV: ${IP_CLAMAV}
  IP_CLIENT_WEB: ${IP_CLIENT_WEB}
  IP_METABASE: ${IP_METABASE}
  IP_MINI_APP: ${IP_MINI_APP}
  IP_MINIO: ${IP_MINIO}
  IP_PARTICIPANT_TMA: ${IP_PARTICIPANT_TMA}
  IP_PGADMIN: ${IP_PGADMIN}
  IP_RANGE_BASE: ${IP_RANGE_BASE}
  IP_SWAGGER_UI: ${IP_SWAGGER_UI}
  IP_TELEGRAM_BOT: ${IP_TELEGRAM_BOT}
  IP_WEBSITE: ${IP_WEBSITE}
  IP_NFT_MANAGER: ${IP_NFT_MANAGER}
  LOCAL_DOMAIN: ${LOCAL_DOMAIN}
  METABASE_DOMAIN: ${METABASE_DOMAIN}
  MINI_APP_DOMAIN: ${MINI_APP_DOMAIN}
  MINI_APP_PORT: ${MINI_APP_PORT}
  MINIO_COLLECTION_BUCKET: ${MINIO_COLLECTION_BUCKET}
  MINIO_DASHBOARD_PORT: ${MINIO_DASHBOARD_PORT}
  MINIO_DOC_BUCKET: ${MINIO_DOC_BUCKET}
  MINIO_DOC_DEFAULT_BUCKET: ${MINIO_DOC_DEFAULT_BUCKET}
  MINIO_ENDPOINT: ${MINIO_ENDPOINT}
  MINIO_IMAGE_BUCKET: ${MINIO_IMAGE_BUCKET}
  MINIO_ITEM_BUCKET: ${MINIO_ITEM_BUCKET}
  MINIO_PORT: ${MINIO_PORT}
  MINIO_PUBLIC_URL: ${MINIO_PUBLIC_URL}
  MINIO_REGION_NAME: ${MINIO_REGION_NAME}
  MINIO_ROOT_PASSWORD: ${MINIO_ROOT_PASSWORD}
  MINIO_ROOT_USER: ${MINIO_ROOT_USER}
  MINIO_SBT_COLLECTIONS_BUCKET: ${MINIO_SBT_COLLECTIONS_BUCKET}
  MINIO_STORAGE_ADMIN_DOMAIN: ${MINIO_STORAGE_ADMIN_DOMAIN}
  MINIO_STORAGE_DOMAIN: ${MINIO_STORAGE_DOMAIN}
  MINIO_VIDEO_BUCKET: ${MINIO_VIDEO_BUCKET}
  MONITORING_DOMAIN: ${MONITORING_DOMAIN}
  NEXT_PUBLIC_API_BASE_URL: ${NEXT_PUBLIC_API_BASE_URL}
  NEXT_PUBLIC_APP_BASE_URL: ${NEXT_PUBLIC_APP_BASE_URL}
  NEXT_PUBLIC_GTM: ${NEXT_PUBLIC_GTM}
  NEXT_PUBLIC_BOT_USERNAME: ${NEXT_PUBLIC_BOT_USERNAME}
  NODE_ENV: ${NODE_ENV}
  NODE_TLS_REJECT_UNAUTHORIZED: ${NODE_TLS_REJECT_UNAUTHORIZED}
  ONTON_API_KEY: ${ONTON_API_KEY}
  ONTON_DOMAIN: ${ONTON_DOMAIN}
  PARTICIPANT_TMA_PORT: ${PARTICIPANT_TMA_PORT}
  PGADMIN_DOMAIN: ${PGADMIN_DOMAIN}
  PORT_CLIENT_WEB: ${PORT_CLIENT_WEB}
  CLAMAV_PORT: ${CLAMAV_PORT}
  PORT_METABASE: ${PORT_METABASE}
  PORT_PGADMIN: ${PORT_PGADMIN}
  PORT_WEB_SITE: ${PORT_WEB_SITE}
  POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
  POSTGRES_PORT: ${POSTGRES_PORT}
  POSTGRES_USER: ${POSTGRES_USER}
  IP_RABBITMQ: ${IP_RABBITMQ}
  NFT_MANAGER_PORT: ${NFT_MANAGER_PORT}
  RABBITMQ_DEFAULT_USER: ${RABBITMQ_DEFAULT_USER}
  RABBITMQ_DEFAULT_PASS: ${RABBITMQ_DEFAULT_PASS}
  RABBITMQ_DOMAIN: ${RABBITMQ_DOMAIN}
  RABBITMQ_MANAGEMENT_PORT: ${RABBITMQ_MANAGEMENT_PORT}
  RABBITMQ_NODE_PORT: ${RABBITMQ_NODE_PORT}
  KIBANA_PORT: ${KIBANA_PORT}
  REDIS_DATABASES: ${REDIS_DATABASES}
  REDIS_HOST: ${IP_REDIS}
  IP_REDIS: ${IP_REDIS}
  REDIS_PASSWORD: ${REDIS_PASSWORD}
  REDIS_PORT: ${REDIS_PORT}
  TELEGRAM_BOT_PORT: ${TELEGRAM_BOT_PORT}
  TG_NOTIFICATION_CHANELL: ${TG_NOTIFICATION_CHANELL}
  TONAPI_API_KEY: ${TONAPI_API_KEY}
  TON_CENTER_TOKEN: ${TON_CENTER_TOKEN}
  TON_CENTER_ENDPOINT: ${TON_CENTER_ENDPOINT}
  DOCKER_CONFIG: "/run/secrets/registry-onton-config"
  MINI_APP_SOCKET_DOMAIN: ${MINI_APP_SOCKET_DOMAIN}
  NEXT_PUBLIC_SOCKET_URL: ${NEXT_PUBLIC_SOCKET_URL}
  IP_SOCKET: ${IP_SOCKET}
  SOCKET_PORT: ${SOCKET_PORT}
  JWT_SECRET_SOCKET: ${JWT_SECRET_SOCKET}

services:
  minio:
    hostname: minio
    image: minio/minio
    depends_on:
      - fluentd
    networks:
      - onton-network
    ports:
      - "${MINIO_PORT}:${MINIO_PORT}"
      - "${MINIO_DASHBOARD_PORT}:${MINIO_DASHBOARD_PORT}"
    deploy:
      resources:
        limits:
          memory: 8000M
          cpus: "3.0"
      mode: global
      update_config:
        failure_action: rollback
        order: stop-first
        parallelism: 1
      placement:
        constraints:
          - node.role == manager
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 20
        window: 300s
    volumes:
      - minio_data:/data
      - ./devops/minio-init.sh:/usr/bin/entrypoint.sh # Mount the script into the container
    entrypoint: ["/usr/bin/entrypoint.sh"] # Use the custom entrypoint script
    environment:
      <<: *common-env
    logging:
      driver: "fluentd"
      options:
        fluentd-address: "127.0.0.1:24224"
        tag: "docker.${BRANCH_NAME}-minio"
        fluentd-async-connect: "true"

  postgres:
    hostname: postgres
    image: postgres:16.3-alpine3.20
    depends_on:
      - fluentd
    ports:
      - "${POSTGRES_PORT}:${POSTGRES_PORT}"
    deploy:
      resources:
        limits:
          memory: 8000M
          cpus: "5.0"
      mode: global
      update_config:
        failure_action: rollback
        order: stop-first
        parallelism: 1
      placement:
        constraints:
          - node.role == manager
      restart_policy:
        condition: on-failure
        delay: 15s
        window: 30s
    stop_grace_period: 120s
    stop_signal: SIGTERM
    environment:
      <<: *common-env
    command: postgres -p ${POSTGRES_PORT}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    networks:
      - onton-network
  #    healthcheck:
  #      test: ["CMD-SHELL", "sh -c 'pg_isready -U ${POSTGRES_USER} -d ${POSTGRES_DB} -h localhost -p ${POSTGRES_PORT} '"]
  #      interval: 30s
  #      timeout: 5s
  #      start_period: 20s
    logging:
      driver: "fluentd"
      options:
        fluentd-address: "127.0.0.1:24224"
        tag: "docker.${BRANCH_NAME}-postgres"
        fluentd-async-connect: "true"

  redis:
    image: redis:7.4.1-bookworm
    hostname: redis
    volumes:
      - redis_data:/data
    depends_on:
      - fluentd
    ports:
      - "${REDIS_PORT}:${REDIS_PORT}"
    command: redis-server  --port ${REDIS_PORT}
    deploy:
      resources:
        limits:
          memory: 3000M
          cpus: "2.0"
      mode: global
      update_config:
        failure_action: rollback
        order: stop-first
        parallelism: 1
      placement:
        constraints:
          - node.role == manager
      restart_policy:
        condition: on-failure
        delay: 10s
        max_attempts: 20
        window: 30s
    stop_signal: SIGTERM
    stop_grace_period: 30s
    environment:
      <<: *common-env
    networks:
      - onton-network
  #    healthcheck:
  #      test: ["CMD-SHELL", "redis-cli -h ${REDIS_HOST} -p ${REDIS_PORT}  ping | grep PONG "]
  #      interval: 30s
  #      timeout: 5s
  #      start_period: 5s
    logging:
      driver: "fluentd"
      options:
        fluentd-address: "127.0.0.1:24224"
        tag: "docker.${BRANCH_NAME}-redis"
        fluentd-async-connect: "true"



  pgadmin:
    image: dpage/pgadmin4
    environment:
      PGADMIN_DEFAULT_EMAIL: ${PGADMIN_DEFAULT_EMAIL}
      PGADMIN_DEFAULT_PASSWORD: ${PGADMIN_DEFAULT_PASSWORD}
      PGADMIN_LISTEN_PORT: ${PORT_PGADMIN}
    depends_on:
      - postgres
    ports:
      - "${PORT_PGADMIN}:${PORT_PGADMIN}"
    networks:
      - onton-network
    volumes:
      - pgadmin:/var/lib/pgadmin

  telegram-bot:
    image: ${REGISTRY_URL}/${GITHUB_REPO}/telegram-bot:${BRANCH_NAME}-latest
    hostname: telegram-bot
    deploy:
      resources:
        limits:
          memory: 3000M
          cpus: "2.0"
      mode: global
      update_config:
        failure_action: rollback
        order: stop-first
        parallelism: 1
      placement:
        constraints:
          - node.role == manager
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 20
        window: 300s
    environment:
      <<: *common-env
    depends_on:
      - postgres
      - fluentd
      - redis
    secrets:
      - registry-onton-config
    networks:
      - onton-network
    logging:
      driver: "fluentd"
      options:
        fluentd-address: "127.0.0.1:24224"
        tag: "docker.${BRANCH_NAME}-telegram-bot"
        fluentd-async-connect: "true"

  mini-app:
    hostname: mini-app
    image: ${REGISTRY_URL}/${GITHUB_REPO}/mini-app:${BRANCH_NAME}-latest
    ports:
      - "${MINI_APP_PORT}:${MINI_APP_PORT}"
    <<: *default-extra-hosts
    deploy:
      resources:
        limits:
          memory: 3000M
          cpus: "2.0"
      replicas: ${SYS_MINI_APP_REPLICAS:-2}
      update_config:
        failure_action: rollback
        order: start-first
      restart_policy:
        condition: any
        delay: 3s
    environment:
      <<: *common-env
      TON_SOCIETY_API_KEY: ${TON_SOCIETY_API_KEY}
      TON_SOCIETY_BASE_URL: ${TON_SOCIETY_BASE_URL}
    depends_on:
      - postgres
      - redis
      - minio
      - fluentd
    volumes:
      - drizzle_data:/app/drizzle
    networks:
      - onton-network
    secrets:
      - registry-onton-config
    healthcheck:
      test:
        [
          "CMD-SHELL",
          "curl  http://localhost:${MINI_APP_PORT}/api/client/v1/public/ping | grep -q pong ",
        ]
      interval: 15s
      timeout: 10s
      start_period: 15s
    logging:
      driver: "fluentd"
      options:
        fluentd-address: "127.0.0.1:24224"
        tag: "docker.${BRANCH_NAME}-mini-app"
        fluentd-async-connect: "true"

  mini-app-sbt-worker:
    hostname: mini-app-sbt-worker
    image: ${REGISTRY_URL}/${GITHUB_REPO}/mini-app:${BRANCH_NAME}-latest
    <<: *default-extra-hosts
    deploy:
      resources:
        limits:
          memory: 2000M
          cpus: "2.0"
      mode: global
      update_config:
        failure_action: rollback
        order: start-first
      restart_policy:
        condition: on-failure
        delay: 10s
        max_attempts: 20
        window: 300s
    environment:
      <<: *common-env
      MNEMONIC: ${MNEMONIC}
      TON_SOCIETY_API_KEY: ${TON_SOCIETY_API_KEY}
      TON_SOCIETY_BASE_URL: ${TON_SOCIETY_BASE_URL}
    depends_on:
      - postgres
      - redis
      - minio
      - fluentd
    volumes:
      - drizzle_data_cron:/app/drizzle
    networks:
      - onton-network
    command: ["pnpm", "run", "start-cron"]
    secrets:
      - registry-onton-config
    logging:
      driver: "fluentd"
      options:
        fluentd-address: "127.0.0.1:24224"
        tag: "docker.${BRANCH_NAME}-mini-app-sbt-worker"
        fluentd-async-connect: "true"

  mini-app-poa-worker:
    hostname: mini-app-poa-worker
    image: ${REGISTRY_URL}/${GITHUB_REPO}/mini-app:${BRANCH_NAME}-latest
    <<: *default-extra-hosts
    deploy:
      resources:
        limits:
          memory: 3000M
          cpus: "2.0"
      mode: global
      update_config:
        failure_action: rollback
        order: stop-first
        parallelism: 1
      placement:
        constraints:
          - node.role == manager
      restart_policy:
        condition: on-failure
        delay: 5s
    environment:
      <<: *common-env
      TON_SOCIETY_API_KEY: ${TON_SOCIETY_API_KEY}
      TON_SOCIETY_BASE_URL: ${TON_SOCIETY_BASE_URL}
    depends_on:
      - postgres
      - redis
      - minio
      - rabbitmq
      - fluentd
    volumes:
      - drizzle_data_cron:/app/drizzle
    networks:
      - onton-network
    command: ["pnpm", "run", "start:poa"]
    secrets:
      - registry-onton-config
    logging:
      driver: "fluentd"
      options:
        fluentd-address: "127.0.0.1:24224"
        tag: "docker.${BRANCH_NAME}-mini-app-poa-worker"
        fluentd-async-connect: "true"


  mini-app-notification-socket:
    hostname: mini-app-notification-socket
    image: ${REGISTRY_URL}/${GITHUB_REPO}/mini-app:${BRANCH_NAME}-latest
    <<: *default-extra-hosts
    ports:
      - "${SOCKET_PORT}:${SOCKET_PORT}"
    deploy:
      resources:
        limits:
          memory: 3000M
          cpus: "2.0"
      replicas: 3
      update_config:
        failure_action: rollback
        order: start-first
      restart_policy:
        condition: any
        delay: 20s
    environment:
      <<: *common-env
      TON_SOCIETY_API_KEY: ${TON_SOCIETY_API_KEY}
      TON_SOCIETY_BASE_URL: ${TON_SOCIETY_BASE_URL}
    depends_on:
      - postgres
      - redis
      - minio
      - rabbitmq
      - mini-app-poa-worker
      - fluentd
    volumes:
      - drizzle_data_cron:/app/drizzle
    networks:
      - onton-network
    command: ["pnpm", "run", "start:socket"]
    secrets:
      - registry-onton-config
    logging:
      driver: "fluentd"
      options:
        fluentd-address: "127.0.0.1:24224"
        tag: "docker.${BRANCH_NAME}-mini-app-notification-socket"
        fluentd-async-connect: "true"


  participant-tma:
    hostname: participant-tma
    image: ${REGISTRY_URL}/${GITHUB_REPO}/participant-tma:${BRANCH_NAME}-latest
    ports:
      - "${PARTICIPANT_TMA_PORT}:${PARTICIPANT_TMA_PORT}"
    deploy:
      resources:
        limits:
          memory: 3000M
          cpus: "2.0"
      replicas: "${SYS_PARTICIPANT_TMA_REPLICAS-1}"
      update_config:
        failure_action: rollback
        order: start-first
      restart_policy:
        condition: any
        delay: 3s
    depends_on:
      - mini-app
      - fluentd
    environment:
      <<: *common-env
    networks:
      - onton-network
    secrets:
      - registry-onton-config
    logging:
      driver: "fluentd"
      options:
        fluentd-address: "127.0.0.1:24224"
        tag: "docker.${BRANCH_NAME}-participant-tma"
        fluentd-async-connect: "true"

#  nft-manager:
#    hostname: nft-manager
#    image: ${REGISTRY_URL}/${GITHUB_REPO}/nft-manager:${BRANCH_NAME}-latest
#    deploy:
#      resources:
#        limits:
#          memory: 3000M
#          cpus: "3.0"
#      mode: global
#      update_config:
#        failure_action: rollback
#        order: start-first
#        parallelism: 1
#      placement:
#        constraints:
#          - node.role == manager
#      restart_policy:
#        condition: on-failure
#        delay: 10s
#    depends_on:
#      - postgres
#      - redis
#      - minio
#      - mini-app
#      - fluentd
#    environment:
#      <<: *common-env
#      MNEMONIC: ${MNEMONIC}
#    networks:
#      - onton-network
#    secrets:
#      - registry-onton-config
#    logging:
#      driver: "fluentd"
#      options:
#        fluentd-address: "127.0.0.1:24224"
#        tag: "docker.${BRANCH_NAME}-nft-manager"
#        fluentd-async-connect: "true"


  website:
    hostname: website
    image: ${REGISTRY_URL}/${GITHUB_REPO}/website:${BRANCH_NAME}-latest
    ports:
      - "${PORT_WEB_SITE}:${PORT_WEB_SITE}"
    depends_on:
      - fluentd
    deploy:
      resources:
        limits:
          memory: 2000M
          cpus: "1.0"
      replicas: "${SYS_WEB_SITE_REPLICAS-1}"
      update_config:
        failure_action: rollback
        order: start-first
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 20
        window: 300s
    environment:
      <<: *common-env
    networks:
      - onton-network
    logging:
      driver: "fluentd"
      options:
        fluentd-address: "127.0.0.1:24224"
        tag: "docker.${BRANCH_NAME}-website"
        fluentd-async-connect: "true"

  metabase:
    image: metabase/metabase:v0.50.18.3
    hostname: metabase
    ports:
      - "${PORT_METABASE}:3000"
    deploy:
      resources:
        limits:
          memory: 2000M
          cpus: '2.0'
      mode: global
      update_config:
        failure_action: rollback
        order: stop-first
        parallelism: 1
      placement:
        constraints:
          - node.role == manager
      restart_policy:
        condition: on-failure
        delay: 15s
        max_attempts: 5
        window: 300s
    volumes:
      - /dev/urandom:/dev/random:ro
    environment:
      MB_DB_TYPE: postgres
      MB_DB_DBNAME: ${POSTGRES_MINI_APP_DB}
      MB_DB_PORT: ${POSTGRES_PORT}
      MB_DB_USER: ${POSTGRES_USER}
      MB_DB_PASS: ${POSTGRES_PASSWORD}
      MB_DB_HOST: postgres
      MB_LOG_LEVEL: DEBUG
      MB_ENCRYPTION_SECRET_KEY: "${MB_ENCRYPTION_SECRET_KEY}"
      MB_REDIRECT_ALL_REQUESTS_TO_HTTPS: ${MB_REDIRECT_ALL_REQUESTS_TO_HTTPS}
    networks:
      - onton-network
    depends_on:
      - postgres
      - fluentd
    healthcheck:
      test: curl --fail -I http://localhost:3000/api/health || exit 1
      interval: 15s
      timeout: 5s
      retries: 5
    logging:
      driver: "fluentd"
      options:
        fluentd-address: "127.0.0.1:24224"
        tag: "docker.${BRANCH_NAME}-metabase"
        fluentd-async-connect: "true"

  rabbitmq:
    image: "rabbitmq:4.0.4-management-alpine"
    hostname: rabbitmq
    ports:
      - "${RABBITMQ_MANAGEMENT_PORT}:15672"
      - "${RABBITMQ_NODE_PORT}:${RABBITMQ_NODE_PORT}"
    environment:
      RABBITMQ_DEFAULT_USER: "${RABBITMQ_DEFAULT_USER}"
      RABBITMQ_DEFAULT_PASS: "${RABBITMQ_DEFAULT_PASS}"
      RABBITMQ_NODE_PORT: "${RABBITMQ_NODE_PORT}"
#    volumes:
#      - rabbitmq_data:/var/lib/rabbitmq  # Persist data
    depends_on:
      - fluentd
    deploy:
      mode: global
      resources:
        limits:
          memory: 4096M
          cpus: "3.0"
        reservations:
          memory: 2048M
          cpus: "1.0"
      restart_policy:
        condition: on-failure
        delay: 15s
        max_attempts: 5
        window: 30s
      update_config:
        parallelism: 1
        delay: 10s
        failure_action: rollback
        order: stop-first
      placement:
        constraints:
          - node.role == manager
    stop_grace_period: 30s
    stop_signal: SIGTERM
    networks:
      - onton-network
    tty: true
    logging:
      driver: "fluentd"
      options:
        fluentd-address: "127.0.0.1:24224"
        tag: "docker.${BRANCH_NAME}-rabbitmq"
        fluentd-async-connect: "true"

#  client-web:
#    hostname: client-web
#    <<: *default-extra-hosts
#    image: ${REGISTRY_URL}/${GITHUB_REPO}/client-web:${BRANCH_NAME}-latest
#    ports:
#      - "${PORT_CLIENT_WEB}:${PORT_CLIENT_WEB}"
#    environment:
#      NEXT_PUBLIC_BACKEND_URL_CLIENT: ${NEXT_PUBLIC_BACKEND_URL_CLIENT}
#      CLIENT_API_JWT_SECRET: ${CLIENT_API_JWT_SECRET}
#      CLIENT_API_FIXED_KEY: ${CLIENT_API_FIXED_KEY}
#      CLIENT_API_FIXED_USER: ${CLIENT_API_FIXED_USER}
#      CLIENT_API_FIXED_ORGANIZER: ${CLIENT_API_FIXED_ORGANIZER}
#      PORT_CLIENT_WEB: ${PORT_CLIENT_WEB}
#    networks:
#      - onton-network
#    logging:
#        driver: "fluentd"
#        options:
#            syslog-address: "logstash:5044"
#            tag: "docker.${BRANCH_NAME}-client-web"
#            fluentd-async-connect: "true"


#  swagger-ui:
#    image: swaggerapi/swagger-ui
#    environment:
#      SWAGGER_JSON: /swagger.yaml
#    volumes:
#      - ./swagger/swagger.yaml:/swagger.yaml
#    networks:
#      onton-network:
#        ipv4_address: "${IP_SWAGGER_UI}"

networks:
  onton-network:
    name: onton-network-${BRANCH_NAME}
    driver: overlay
    external: true

volumes:
  pgadmin:
    name: "${STAGE_NAME}_pgadmin"
  minio_data:
    driver: local
    name: "${STAGE_NAME}_minio_data"
  postgres_data:
    driver: local
    name: "${STAGE_NAME}_postgres_data"
  redis_data:
    driver: local
    name: "${STAGE_NAME}_redis_data"
  drizzle_data:
    name: "${STAGE_NAME}_drizzle_data"
  drizzle_data_cron:
    name: "${STAGE_NAME}_drizzle_data_cron"
#  rabbitmq_data:
#    driver: local
#    name: "${STAGE_NAME}_rabbitmq_data"
secrets:
  registry-onton-config:
    external: true